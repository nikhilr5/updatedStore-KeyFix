{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { createNoDashGuid, Deferred } from \"../../common/Exports\";\n/**\n * Placeholder class for the Conversation Request Session. Based off RequestSession.\n * TODO: define what telemetry is required.\n */\n\nexport class ConversationRequestSession {\n  constructor(sessionId) {\n    this.privIsDisposed = false;\n    this.privDetachables = new Array();\n\n    this.onPreConnectionStart = (authFetchEventId, connectionId) => {\n      this.privSessionId = connectionId;\n    };\n\n    this.onAuthCompleted = (isError, error) => {\n      if (isError) {\n        this.onComplete();\n      }\n    };\n\n    this.onConnectionEstablishCompleted = (statusCode, reason) => {\n      if (statusCode === 200) {\n        return;\n      } else if (statusCode === 403) {\n        this.onComplete();\n      }\n    };\n\n    this.onServiceTurnEndResponse = continuousRecognition => {\n      if (!continuousRecognition) {\n        this.onComplete();\n      } else {\n        this.privRequestId = createNoDashGuid();\n      }\n    };\n\n    this.dispose = error => {\n      if (!this.privIsDisposed) {\n        // we should have completed by now. If we did not its an unknown error.\n        this.privIsDisposed = true;\n\n        for (const detachable of this.privDetachables) {\n          detachable.detach();\n        }\n      }\n    };\n\n    this.onComplete = () => {//\n    };\n\n    this.privSessionId = sessionId;\n    this.privRequestId = createNoDashGuid();\n    this.privRequestCompletionDeferral = new Deferred();\n  }\n\n  get sessionId() {\n    return this.privSessionId;\n  }\n\n  get requestId() {\n    return this.privRequestId;\n  }\n\n  get completionPromise() {\n    return this.privRequestCompletionDeferral.promise();\n  }\n\n}","map":{"version":3,"sources":["src/common.speech/Transcription/ConversationRequestSession.ts"],"names":[],"mappings":"AAAA;AACA;AAEA,SACI,gBADJ,EAEI,QAFJ,QAKO,sBALP;AAOA;;;;;AAIA,OAAM,MAAO,0BAAP,CAAiC;AAOnC,EAAA,WAAA,CAAY,SAAZ,EAA6B;AANrB,SAAA,cAAA,GAA0B,KAA1B;AACA,SAAA,eAAA,GAAiC,IAAI,KAAJ,EAAjC;;AAuBD,SAAA,oBAAA,GAAuB,CAAC,gBAAD,EAA2B,YAA3B,KAAyD;AACnF,WAAK,aAAL,GAAqB,YAArB;AACH,KAFM;;AAIA,SAAA,eAAA,GAAkB,CAAC,OAAD,EAAmB,KAAnB,KAA2C;AAChE,UAAI,OAAJ,EAAa;AACT,aAAK,UAAL;AACH;AACJ,KAJM;;AAMA,SAAA,8BAAA,GAAiC,CAAC,UAAD,EAAqB,MAArB,KAA8C;AAClF,UAAI,UAAU,KAAK,GAAnB,EAAwB;AACpB;AACH,OAFD,MAEO,IAAI,UAAU,KAAK,GAAnB,EAAwB;AAC3B,aAAK,UAAL;AACH;AACJ,KANM;;AAQA,SAAA,wBAAA,GAA4B,qBAAD,IAAyC;AACvE,UAAI,CAAC,qBAAL,EAA4B;AACxB,aAAK,UAAL;AACH,OAFD,MAEO;AACH,aAAK,aAAL,GAAqB,gBAAgB,EAArC;AACH;AACJ,KANM;;AAQA,SAAA,OAAA,GAAW,KAAD,IAAyB;AACtC,UAAI,CAAC,KAAK,cAAV,EAA0B;AACtB;AACA,aAAK,cAAL,GAAsB,IAAtB;;AACA,aAAK,MAAM,UAAX,IAAyB,KAAK,eAA9B,EAA+C;AAC3C,UAAA,UAAU,CAAC,MAAX;AACH;AACJ;AACJ,KARM;;AAUC,SAAA,UAAA,GAAa,MAAW,CAC5B;AACH,KAFO;;AArDJ,SAAK,aAAL,GAAqB,SAArB;AACA,SAAK,aAAL,GAAqB,gBAAgB,EAArC;AACA,SAAK,6BAAL,GAAqC,IAAI,QAAJ,EAArC;AACH;;AAED,MAAW,SAAX,GAAoB;AAChB,WAAO,KAAK,aAAZ;AACH;;AAED,MAAW,SAAX,GAAoB;AAChB,WAAO,KAAK,aAAZ;AACH;;AAED,MAAW,iBAAX,GAA4B;AACxB,WAAO,KAAK,6BAAL,CAAmC,OAAnC,EAAP;AACH;;AAvBkC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    createNoDashGuid,\r\n    Deferred,\r\n    IDetachable,\r\n    Promise,\r\n} from \"../../common/Exports\";\r\n\r\n/**\r\n * Placeholder class for the Conversation Request Session. Based off RequestSession.\r\n * TODO: define what telemetry is required.\r\n */\r\nexport class ConversationRequestSession {\r\n    private privIsDisposed: boolean = false;\r\n    private privDetachables: IDetachable[] = new Array<IDetachable>();\r\n    private privRequestId: string;\r\n    private privRequestCompletionDeferral: Deferred<boolean>;\r\n    private privSessionId: string;\r\n\r\n    constructor(sessionId: string) {\r\n        this.privSessionId = sessionId;\r\n        this.privRequestId = createNoDashGuid();\r\n        this.privRequestCompletionDeferral = new Deferred<boolean>();\r\n    }\r\n\r\n    public get sessionId(): string {\r\n        return this.privSessionId;\r\n    }\r\n\r\n    public get requestId(): string {\r\n        return this.privRequestId;\r\n    }\r\n\r\n    public get completionPromise(): Promise<boolean> {\r\n        return this.privRequestCompletionDeferral.promise();\r\n    }\r\n\r\n    public onPreConnectionStart = (authFetchEventId: string, connectionId: string): void => {\r\n        this.privSessionId = connectionId;\r\n    }\r\n\r\n    public onAuthCompleted = (isError: boolean, error?: string): void => {\r\n        if (isError) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onConnectionEstablishCompleted = (statusCode: number, reason?: string): void => {\r\n        if (statusCode === 200) {\r\n            return;\r\n        } else if (statusCode === 403) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onServiceTurnEndResponse = (continuousRecognition: boolean): void => {\r\n        if (!continuousRecognition) {\r\n            this.onComplete();\r\n        } else {\r\n            this.privRequestId = createNoDashGuid();\r\n        }\r\n    }\r\n\r\n    public dispose = (error?: string): void => {\r\n        if (!this.privIsDisposed) {\r\n            // we should have completed by now. If we did not its an unknown error.\r\n            this.privIsDisposed = true;\r\n            for (const detachable of this.privDetachables) {\r\n                detachable.detach();\r\n            }\r\n        }\r\n    }\r\n\r\n    private onComplete = (): void => {\r\n        //\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}