{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ArgumentNullError, ConnectionClosedEvent, ConnectionErrorEvent, ConnectionEstablishedEvent, ConnectionMessageReceivedEvent, ConnectionMessageSentEvent, ConnectionOpenResponse, ConnectionStartEvent, ConnectionState, Deferred, Events, EventSource, MessageType, PromiseHelper, Queue, RawWebsocketMessage } from \"../common/Exports\";\nimport * as HttpsProxyAgent from \"https-proxy-agent\";\nimport * as ws from \"ws\";\nimport * as ocsp from \"../../external/ocsp/ocsp\";\nexport class WebsocketMessageAdapter {\n  constructor(uri, connectionId, messageFormatter, proxyInfo, headers) {\n    this.open = () => {\n      if (this.privConnectionState === ConnectionState.Disconnected) {\n        return PromiseHelper.fromError(`Cannot open a connection that is in ${this.privConnectionState} state`);\n      }\n\n      if (this.privConnectionEstablishDeferral) {\n        return this.privConnectionEstablishDeferral.promise();\n      }\n\n      this.privConnectionEstablishDeferral = new Deferred();\n      this.privCertificateValidatedDeferral = new Deferred();\n      this.privConnectionState = ConnectionState.Connecting;\n\n      try {\n        const enableOCSP = typeof process !== \"undefined\" && process.env.NODE_TLS_REJECT_UNAUTHORIZED !== \"0\" && process.env.SPEECH_CONDUCT_OCSP_CHECK !== \"0\" && !this.privUri.startsWith(\"ws:\");\n\n        if (typeof WebSocket !== \"undefined\" && !WebsocketMessageAdapter.forceNpmWebSocket) {\n          // Browser handles cert checks.\n          this.privCertificateValidatedDeferral.resolve(true);\n          this.privWebsocketClient = new WebSocket(this.privUri);\n        } else {\n          if (this.proxyInfo !== undefined && this.proxyInfo.HostName !== undefined && this.proxyInfo.Port > 0) {\n            const httpProxyOptions = {\n              host: this.proxyInfo.HostName,\n              port: this.proxyInfo.Port\n            };\n\n            if (undefined !== this.proxyInfo.UserName) {\n              httpProxyOptions.headers = {\n                \"Proxy-Authentication\": \"Basic \" + new Buffer(this.proxyInfo.UserName + \":\" + (this.proxyInfo.Password === undefined) ? \"\" : this.proxyInfo.Password).toString(\"base64\")\n              };\n\n              if (enableOCSP) {\n                httpProxyOptions.headers.requestOCSP = \"true\";\n              }\n            }\n\n            const httpProxyAgent = new HttpsProxyAgent(httpProxyOptions);\n            const httpsOptions = {\n              agent: httpProxyAgent,\n              headers: this.privHeaders\n            };\n            this.privWebsocketClient = new ws(this.privUri, httpsOptions); // Register to be notified when WebSocket upgrade happens so we can check the validity of the\n            // Certificate.\n\n            if (enableOCSP) {\n              this.privWebsocketClient.addListener(\"upgrade\", e => {\n                const tlsSocket = e.socket;\n                const peer = tlsSocket.getPeerCertificate(true); // Cork the socket until we know if the cert is good.\n\n                tlsSocket.cork();\n                ocsp.check({\n                  cert: peer.raw,\n                  httpOptions: httpsOptions,\n                  issuer: peer.issuerCertificate.raw\n                }, (error, res) => {\n                  if (error) {\n                    this.privCertificateValidatedDeferral.reject(error.message);\n                    tlsSocket.destroy(error);\n                  } else {\n                    this.privCertificateValidatedDeferral.resolve(true);\n                    tlsSocket.uncork();\n                  }\n                });\n              });\n            } else {\n              this.privCertificateValidatedDeferral.resolve(true);\n            }\n          } else {\n            const options = {\n              headers: this.privHeaders\n            }; // The ocsp library will handle validation for us and fail the connection if needed.\n\n            this.privCertificateValidatedDeferral.resolve(true);\n\n            if (enableOCSP) {\n              options.agent = new ocsp.Agent({});\n            }\n\n            this.privWebsocketClient = new ws(this.privUri, options);\n          }\n        }\n\n        this.privWebsocketClient.binaryType = \"arraybuffer\";\n        this.privReceivingMessageQueue = new Queue();\n        this.privDisconnectDeferral = new Deferred();\n        this.privSendMessageQueue = new Queue();\n        this.processSendQueue();\n      } catch (error) {\n        this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(500, error));\n        return this.privConnectionEstablishDeferral.promise();\n      }\n\n      this.onEvent(new ConnectionStartEvent(this.privConnectionId, this.privUri));\n\n      this.privWebsocketClient.onopen = e => {\n        this.privCertificateValidatedDeferral.promise().on(() => {\n          this.privConnectionState = ConnectionState.Connected;\n          this.onEvent(new ConnectionEstablishedEvent(this.privConnectionId));\n          this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(200, \"\"));\n        }, error => {\n          this.privConnectionEstablishDeferral.reject(error);\n        });\n      };\n\n      this.privWebsocketClient.onerror = e => {\n        this.onEvent(new ConnectionErrorEvent(this.privConnectionId, e.message, e.type));\n        this.privLastErrorReceived = e.message;\n      };\n\n      this.privWebsocketClient.onclose = e => {\n        if (this.privConnectionState === ConnectionState.Connecting) {\n          this.privConnectionState = ConnectionState.Disconnected; // this.onEvent(new ConnectionEstablishErrorEvent(this.connectionId, e.code, e.reason));\n\n          this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(e.code, e.reason + \" \" + this.privLastErrorReceived));\n        } else {\n          this.onEvent(new ConnectionClosedEvent(this.privConnectionId, e.code, e.reason));\n        }\n\n        this.onClose(e.code, e.reason);\n      };\n\n      this.privWebsocketClient.onmessage = e => {\n        const networkReceivedTime = new Date().toISOString();\n\n        if (this.privConnectionState === ConnectionState.Connected) {\n          const deferred = new Deferred(); // let id = ++this.idCounter;\n\n          this.privReceivingMessageQueue.enqueueFromPromise(deferred.promise());\n\n          if (e.data instanceof ArrayBuffer) {\n            const rawMessage = new RawWebsocketMessage(MessageType.Binary, e.data);\n            this.privMessageFormatter.toConnectionMessage(rawMessage).on(connectionMessage => {\n              this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\n              deferred.resolve(connectionMessage);\n            }, error => {\n              // TODO: Events for these ?\n              deferred.reject(`Invalid binary message format. Error: ${error}`);\n            });\n          } else {\n            const rawMessage = new RawWebsocketMessage(MessageType.Text, e.data);\n            this.privMessageFormatter.toConnectionMessage(rawMessage).on(connectionMessage => {\n              this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\n              deferred.resolve(connectionMessage);\n            }, error => {\n              // TODO: Events for these ?\n              deferred.reject(`Invalid text message format. Error: ${error}`);\n            });\n          }\n        }\n      };\n\n      return this.privConnectionEstablishDeferral.promise();\n    };\n\n    this.send = message => {\n      if (this.privConnectionState !== ConnectionState.Connected) {\n        return PromiseHelper.fromError(`Cannot send on connection that is in ${this.privConnectionState} state`);\n      }\n\n      const messageSendStatusDeferral = new Deferred();\n      const messageSendDeferral = new Deferred();\n      this.privSendMessageQueue.enqueueFromPromise(messageSendDeferral.promise());\n      this.privMessageFormatter.fromConnectionMessage(message).on(rawMessage => {\n        messageSendDeferral.resolve({\n          Message: message,\n          RawWebsocketMessage: rawMessage,\n          sendStatusDeferral: messageSendStatusDeferral\n        });\n      }, error => {\n        messageSendDeferral.reject(`Error formatting the message. ${error}`);\n      });\n      return messageSendStatusDeferral.promise();\n    };\n\n    this.read = () => {\n      if (this.privConnectionState !== ConnectionState.Connected) {\n        return PromiseHelper.fromError(`Cannot read on connection that is in ${this.privConnectionState} state`);\n      }\n\n      return this.privReceivingMessageQueue.dequeue();\n    };\n\n    this.close = reason => {\n      if (this.privWebsocketClient) {\n        if (this.privConnectionState !== ConnectionState.Disconnected) {\n          this.privWebsocketClient.close(1000, reason ? reason : \"Normal closure by client\");\n        }\n      } else {\n        const deferral = new Deferred();\n        deferral.resolve(true);\n        return deferral.promise();\n      }\n\n      return this.privDisconnectDeferral.promise();\n    };\n\n    this.sendRawMessage = sendItem => {\n      try {\n        // indicates we are draining the queue and it came with no message;\n        if (!sendItem) {\n          return PromiseHelper.fromResult(true);\n        }\n\n        this.onEvent(new ConnectionMessageSentEvent(this.privConnectionId, new Date().toISOString(), sendItem.Message)); // add a check for the ws readystate in order to stop the red console error 'WebSocket is already in CLOSING or CLOSED state' appearing\n\n        if (this.isWebsocketOpen) {\n          this.privWebsocketClient.send(sendItem.RawWebsocketMessage.payload);\n        } else {\n          return PromiseHelper.fromError(\"websocket send error: Websocket not ready\");\n        }\n\n        return PromiseHelper.fromResult(true);\n      } catch (e) {\n        return PromiseHelper.fromError(`websocket send error: ${e}`);\n      }\n    };\n\n    this.onClose = (code, reason) => {\n      const closeReason = `Connection closed. ${code}: ${reason}`;\n      this.privConnectionState = ConnectionState.Disconnected;\n      this.privDisconnectDeferral.resolve(true);\n      this.privReceivingMessageQueue.dispose(reason);\n      this.privReceivingMessageQueue.drainAndDispose(pendingReceiveItem => {// TODO: Events for these ?\n        // Logger.instance.onEvent(new LoggingEvent(LogType.Warning, null, `Failed to process received message. Reason: ${closeReason}, Message: ${JSON.stringify(pendingReceiveItem)}`));\n      }, closeReason);\n      this.privSendMessageQueue.drainAndDispose(pendingSendItem => {\n        pendingSendItem.sendStatusDeferral.reject(closeReason);\n      }, closeReason);\n    };\n\n    this.processSendQueue = () => {\n      this.privSendMessageQueue.dequeue().on(sendItem => {\n        // indicates we are draining the queue and it came with no message;\n        if (!sendItem) {\n          return;\n        }\n\n        this.sendRawMessage(sendItem).on(result => {\n          sendItem.sendStatusDeferral.resolve(result);\n          this.processSendQueue();\n        }, sendError => {\n          sendItem.sendStatusDeferral.reject(sendError);\n          this.processSendQueue();\n        });\n      }, error => {// do nothing\n      });\n    };\n\n    this.onEvent = event => {\n      this.privConnectionEvents.onEvent(event);\n      Events.instance.onEvent(event);\n    };\n\n    if (!uri) {\n      throw new ArgumentNullError(\"uri\");\n    }\n\n    if (!messageFormatter) {\n      throw new ArgumentNullError(\"messageFormatter\");\n    }\n\n    this.proxyInfo = proxyInfo;\n    this.privConnectionEvents = new EventSource();\n    this.privConnectionId = connectionId;\n    this.privMessageFormatter = messageFormatter;\n    this.privConnectionState = ConnectionState.None;\n    this.privUri = uri;\n    this.privHeaders = headers;\n    this.privLastErrorReceived = \"\";\n  }\n\n  get state() {\n    return this.privConnectionState;\n  }\n\n  get events() {\n    return this.privConnectionEvents;\n  }\n\n  get isWebsocketOpen() {\n    return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;\n  }\n\n}\nWebsocketMessageAdapter.forceNpmWebSocket = false;","map":{"version":3,"sources":["src/common.browser/WebsocketMessageAdapter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ArgumentNullError,\r\n    ConnectionClosedEvent,\r\n    ConnectionErrorEvent,\r\n    ConnectionEstablishedEvent,\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionMessageReceivedEvent,\r\n    ConnectionMessageSentEvent,\r\n    ConnectionOpenResponse,\r\n    ConnectionStartEvent,\r\n    ConnectionState,\r\n    Deferred,\r\n    Events,\r\n    EventSource,\r\n    IWebsocketMessageFormatter,\r\n    MessageType,\r\n    Promise,\r\n    PromiseHelper,\r\n    Queue,\r\n    RawWebsocketMessage,\r\n} from \"../common/Exports\";\r\nimport { ProxyInfo } from \"./ProxyInfo\";\r\n\r\n// Node.JS specific web socket / browser support.\r\nimport * as http from \"http\";\r\nimport * as HttpsProxyAgent from \"https-proxy-agent\";\r\nimport * as tls from \"tls\";\r\nimport * as ws from \"ws\";\r\nimport * as ocsp from \"../../external/ocsp/ocsp\";\r\n\r\ninterface ISendItem {\r\n    Message: ConnectionMessage;\r\n    RawWebsocketMessage: RawWebsocketMessage;\r\n    sendStatusDeferral: Deferred<boolean>;\r\n}\r\n\r\nexport class WebsocketMessageAdapter {\r\n    private privConnectionState: ConnectionState;\r\n    private privMessageFormatter: IWebsocketMessageFormatter;\r\n    private privWebsocketClient: WebSocket | ws;\r\n\r\n    private privSendMessageQueue: Queue<ISendItem>;\r\n    private privReceivingMessageQueue: Queue<ConnectionMessage>;\r\n    private privConnectionEstablishDeferral: Deferred<ConnectionOpenResponse>;\r\n    private privCertificateValidatedDeferral: Deferred<boolean>;\r\n    private privDisconnectDeferral: Deferred<boolean>;\r\n    private privConnectionEvents: EventSource<ConnectionEvent>;\r\n    private privConnectionId: string;\r\n    private privUri: string;\r\n    private proxyInfo: ProxyInfo;\r\n    private privHeaders: { [key: string]: string; };\r\n    private privLastErrorReceived: string;\r\n\r\n    public static forceNpmWebSocket: boolean = false;\r\n\r\n    public constructor(\r\n        uri: string,\r\n        connectionId: string,\r\n        messageFormatter: IWebsocketMessageFormatter,\r\n        proxyInfo: ProxyInfo,\r\n        headers: { [key: string]: string; }) {\r\n\r\n        if (!uri) {\r\n            throw new ArgumentNullError(\"uri\");\r\n        }\r\n\r\n        if (!messageFormatter) {\r\n            throw new ArgumentNullError(\"messageFormatter\");\r\n        }\r\n\r\n        this.proxyInfo = proxyInfo;\r\n        this.privConnectionEvents = new EventSource<ConnectionEvent>();\r\n        this.privConnectionId = connectionId;\r\n        this.privMessageFormatter = messageFormatter;\r\n        this.privConnectionState = ConnectionState.None;\r\n        this.privUri = uri;\r\n        this.privHeaders = headers;\r\n        this.privLastErrorReceived = \"\";\r\n    }\r\n\r\n    public get state(): ConnectionState {\r\n        return this.privConnectionState;\r\n    }\r\n\r\n    public open = (): Promise<ConnectionOpenResponse> => {\r\n        if (this.privConnectionState === ConnectionState.Disconnected) {\r\n            return PromiseHelper.fromError<ConnectionOpenResponse>(`Cannot open a connection that is in ${this.privConnectionState} state`);\r\n        }\r\n\r\n        if (this.privConnectionEstablishDeferral) {\r\n            return this.privConnectionEstablishDeferral.promise();\r\n        }\r\n\r\n        this.privConnectionEstablishDeferral = new Deferred<ConnectionOpenResponse>();\r\n        this.privCertificateValidatedDeferral = new Deferred<boolean>();\r\n\r\n        this.privConnectionState = ConnectionState.Connecting;\r\n\r\n        try {\r\n            const enableOCSP: boolean = (typeof process !== \"undefined\" && process.env.NODE_TLS_REJECT_UNAUTHORIZED !== \"0\" && process.env.SPEECH_CONDUCT_OCSP_CHECK !== \"0\") && !this.privUri.startsWith(\"ws:\");\r\n\r\n            if (typeof WebSocket !== \"undefined\" && !WebsocketMessageAdapter.forceNpmWebSocket) {\r\n                // Browser handles cert checks.\r\n                this.privCertificateValidatedDeferral.resolve(true);\r\n\r\n                this.privWebsocketClient = new WebSocket(this.privUri);\r\n            } else {\r\n                if (this.proxyInfo !== undefined &&\r\n                    this.proxyInfo.HostName !== undefined &&\r\n                    this.proxyInfo.Port > 0) {\r\n                    const httpProxyOptions: HttpsProxyAgent.HttpsProxyAgentOptions = {\r\n                        host: this.proxyInfo.HostName,\r\n                        port: this.proxyInfo.Port,\r\n                    };\r\n\r\n                    if (undefined !== this.proxyInfo.UserName) {\r\n                        httpProxyOptions.headers = {\r\n                            \"Proxy-Authentication\": \"Basic \" + new Buffer(this.proxyInfo.UserName + \":\" + (this.proxyInfo.Password === undefined) ? \"\" : this.proxyInfo.Password).toString(\"base64\"),\r\n                        };\r\n                        if (enableOCSP) {\r\n                            httpProxyOptions.headers.requestOCSP = \"true\";\r\n                        }\r\n                    }\r\n\r\n                    const httpProxyAgent: HttpsProxyAgent = new HttpsProxyAgent(httpProxyOptions);\r\n                    const httpsOptions: http.RequestOptions = { agent: httpProxyAgent, headers: this.privHeaders };\r\n\r\n                    this.privWebsocketClient = new ws(this.privUri, httpsOptions as ws.ClientOptions);\r\n\r\n                    // Register to be notified when WebSocket upgrade happens so we can check the validity of the\r\n                    // Certificate.\r\n                    if (enableOCSP) {\r\n                        this.privWebsocketClient.addListener(\"upgrade\", (e: http.IncomingMessage): void => {\r\n                            const tlsSocket: tls.TLSSocket = e.socket as tls.TLSSocket;\r\n                            const peer: tls.DetailedPeerCertificate = tlsSocket.getPeerCertificate(true);\r\n\r\n                            // Cork the socket until we know if the cert is good.\r\n                            tlsSocket.cork();\r\n\r\n                            ocsp.check({\r\n                                cert: peer.raw,\r\n                                httpOptions: httpsOptions,\r\n                                issuer: peer.issuerCertificate.raw,\r\n                            }, (error: Error, res: any): void => {\r\n                                if (error) {\r\n                                    this.privCertificateValidatedDeferral.reject(error.message);\r\n                                    tlsSocket.destroy(error);\r\n                                } else {\r\n                                    this.privCertificateValidatedDeferral.resolve(true);\r\n                                    tlsSocket.uncork();\r\n                                }\r\n                            });\r\n                        });\r\n                    } else {\r\n                        this.privCertificateValidatedDeferral.resolve(true);\r\n                    }\r\n\r\n                } else {\r\n                    const options: ws.ClientOptions = { headers: this.privHeaders };\r\n                    // The ocsp library will handle validation for us and fail the connection if needed.\r\n                    this.privCertificateValidatedDeferral.resolve(true);\r\n                    if (enableOCSP) {\r\n                        options.agent = new ocsp.Agent({});\r\n                    }\r\n                    this.privWebsocketClient = new ws(this.privUri, options);\r\n                }\r\n            }\r\n\r\n            this.privWebsocketClient.binaryType = \"arraybuffer\";\r\n            this.privReceivingMessageQueue = new Queue<ConnectionMessage>();\r\n            this.privDisconnectDeferral = new Deferred<boolean>();\r\n            this.privSendMessageQueue = new Queue<ISendItem>();\r\n            this.processSendQueue();\r\n        } catch (error) {\r\n            this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(500, error));\r\n            return this.privConnectionEstablishDeferral.promise();\r\n        }\r\n\r\n        this.onEvent(new ConnectionStartEvent(this.privConnectionId, this.privUri));\r\n\r\n        this.privWebsocketClient.onopen = (e: { target: WebSocket | ws }) => {\r\n            this.privCertificateValidatedDeferral.promise().on((): void => {\r\n                this.privConnectionState = ConnectionState.Connected;\r\n                this.onEvent(new ConnectionEstablishedEvent(this.privConnectionId));\r\n                this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(200, \"\"));\r\n            }, (error: string): void => {\r\n                this.privConnectionEstablishDeferral.reject(error);\r\n            });\r\n        };\r\n\r\n        this.privWebsocketClient.onerror = (e: { error: any; message: string; type: string; target: WebSocket | ws }) => {\r\n            this.onEvent(new ConnectionErrorEvent(this.privConnectionId, e.message, e.type));\r\n            this.privLastErrorReceived = e.message;\r\n        };\r\n\r\n        this.privWebsocketClient.onclose = (e: { wasClean: boolean; code: number; reason: string; target: WebSocket | ws }) => {\r\n            if (this.privConnectionState === ConnectionState.Connecting) {\r\n                this.privConnectionState = ConnectionState.Disconnected;\r\n                // this.onEvent(new ConnectionEstablishErrorEvent(this.connectionId, e.code, e.reason));\r\n                this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(e.code, e.reason + \" \" + this.privLastErrorReceived));\r\n            } else {\r\n                this.onEvent(new ConnectionClosedEvent(this.privConnectionId, e.code, e.reason));\r\n            }\r\n\r\n            this.onClose(e.code, e.reason);\r\n        };\r\n\r\n        this.privWebsocketClient.onmessage = (e: { data: ws.Data; type: string; target: WebSocket | ws }) => {\r\n            const networkReceivedTime = new Date().toISOString();\r\n            if (this.privConnectionState === ConnectionState.Connected) {\r\n                const deferred = new Deferred<ConnectionMessage>();\r\n                // let id = ++this.idCounter;\r\n                this.privReceivingMessageQueue.enqueueFromPromise(deferred.promise());\r\n                if (e.data instanceof ArrayBuffer) {\r\n                    const rawMessage = new RawWebsocketMessage(MessageType.Binary, e.data);\r\n                    this.privMessageFormatter\r\n                        .toConnectionMessage(rawMessage)\r\n                        .on((connectionMessage: ConnectionMessage) => {\r\n                            this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\r\n                            deferred.resolve(connectionMessage);\r\n                        }, (error: string) => {\r\n                            // TODO: Events for these ?\r\n                            deferred.reject(`Invalid binary message format. Error: ${error}`);\r\n                        });\r\n                } else {\r\n                    const rawMessage = new RawWebsocketMessage(MessageType.Text, e.data);\r\n                    this.privMessageFormatter\r\n                        .toConnectionMessage(rawMessage)\r\n                        .on((connectionMessage: ConnectionMessage) => {\r\n                            this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\r\n                            deferred.resolve(connectionMessage);\r\n                        }, (error: string) => {\r\n                            // TODO: Events for these ?\r\n                            deferred.reject(`Invalid text message format. Error: ${error}`);\r\n                        });\r\n                }\r\n            }\r\n        };\r\n\r\n        return this.privConnectionEstablishDeferral.promise();\r\n    }\r\n\r\n    public send = (message: ConnectionMessage): Promise<boolean> => {\r\n        if (this.privConnectionState !== ConnectionState.Connected) {\r\n            return PromiseHelper.fromError<boolean>(`Cannot send on connection that is in ${this.privConnectionState} state`);\r\n        }\r\n\r\n        const messageSendStatusDeferral = new Deferred<boolean>();\r\n        const messageSendDeferral = new Deferred<ISendItem>();\r\n\r\n        this.privSendMessageQueue.enqueueFromPromise(messageSendDeferral.promise());\r\n\r\n        this.privMessageFormatter\r\n            .fromConnectionMessage(message)\r\n            .on((rawMessage: RawWebsocketMessage) => {\r\n                messageSendDeferral.resolve({\r\n                    Message: message,\r\n                    RawWebsocketMessage: rawMessage,\r\n                    sendStatusDeferral: messageSendStatusDeferral,\r\n                });\r\n            }, (error: string) => {\r\n                messageSendDeferral.reject(`Error formatting the message. ${error}`);\r\n            });\r\n\r\n        return messageSendStatusDeferral.promise();\r\n    }\r\n\r\n    public read = (): Promise<ConnectionMessage> => {\r\n        if (this.privConnectionState !== ConnectionState.Connected) {\r\n            return PromiseHelper.fromError<ConnectionMessage>(`Cannot read on connection that is in ${this.privConnectionState} state`);\r\n        }\r\n\r\n        return this.privReceivingMessageQueue.dequeue();\r\n    }\r\n\r\n    public close = (reason?: string): Promise<boolean> => {\r\n        if (this.privWebsocketClient) {\r\n            if (this.privConnectionState !== ConnectionState.Disconnected) {\r\n                this.privWebsocketClient.close(1000, reason ? reason : \"Normal closure by client\");\r\n            }\r\n        } else {\r\n            const deferral = new Deferred<boolean>();\r\n            deferral.resolve(true);\r\n            return deferral.promise();\r\n        }\r\n\r\n        return this.privDisconnectDeferral.promise();\r\n    }\r\n\r\n    public get events(): EventSource<ConnectionEvent> {\r\n        return this.privConnectionEvents;\r\n    }\r\n\r\n    private sendRawMessage = (sendItem: ISendItem): Promise<boolean> => {\r\n        try {\r\n            // indicates we are draining the queue and it came with no message;\r\n            if (!sendItem) {\r\n                return PromiseHelper.fromResult(true);\r\n            }\r\n\r\n            this.onEvent(new ConnectionMessageSentEvent(this.privConnectionId, new Date().toISOString(), sendItem.Message));\r\n\r\n            // add a check for the ws readystate in order to stop the red console error 'WebSocket is already in CLOSING or CLOSED state' appearing\r\n            if (this.isWebsocketOpen) {\r\n                this.privWebsocketClient.send(sendItem.RawWebsocketMessage.payload);\r\n            } else {\r\n                return PromiseHelper.fromError<boolean>(\"websocket send error: Websocket not ready\");\r\n            }\r\n            return PromiseHelper.fromResult(true);\r\n\r\n        } catch (e) {\r\n            return PromiseHelper.fromError<boolean>(`websocket send error: ${e}`);\r\n        }\r\n    }\r\n\r\n    private onClose = (code: number, reason: string): void => {\r\n        const closeReason = `Connection closed. ${code}: ${reason}`;\r\n        this.privConnectionState = ConnectionState.Disconnected;\r\n        this.privDisconnectDeferral.resolve(true);\r\n        this.privReceivingMessageQueue.dispose(reason);\r\n        this.privReceivingMessageQueue.drainAndDispose((pendingReceiveItem: ConnectionMessage) => {\r\n            // TODO: Events for these ?\r\n            // Logger.instance.onEvent(new LoggingEvent(LogType.Warning, null, `Failed to process received message. Reason: ${closeReason}, Message: ${JSON.stringify(pendingReceiveItem)}`));\r\n        }, closeReason);\r\n\r\n        this.privSendMessageQueue.drainAndDispose((pendingSendItem: ISendItem) => {\r\n            pendingSendItem.sendStatusDeferral.reject(closeReason);\r\n        }, closeReason);\r\n    }\r\n\r\n    private processSendQueue = (): void => {\r\n        this.privSendMessageQueue\r\n            .dequeue()\r\n            .on((sendItem: ISendItem) => {\r\n                // indicates we are draining the queue and it came with no message;\r\n                if (!sendItem) {\r\n                    return;\r\n                }\r\n\r\n                this.sendRawMessage(sendItem)\r\n                    .on((result: boolean) => {\r\n                        sendItem.sendStatusDeferral.resolve(result);\r\n                        this.processSendQueue();\r\n                    }, (sendError: string) => {\r\n                        sendItem.sendStatusDeferral.reject(sendError);\r\n                        this.processSendQueue();\r\n                    });\r\n            }, (error: string) => {\r\n                // do nothing\r\n            });\r\n    }\r\n\r\n    private onEvent = (event: ConnectionEvent): void => {\r\n        this.privConnectionEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private get isWebsocketOpen(): boolean {\r\n        return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}