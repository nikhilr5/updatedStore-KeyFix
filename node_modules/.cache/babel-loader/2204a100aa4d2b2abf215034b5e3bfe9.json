{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Contracts } from \"../../sdk/Contracts\";\nimport { PropertyId } from \"../../sdk/Exports\";\nimport { ConversationTranslatorConfig, extractHeaderValue, request } from \"./ConversationUtils\";\nexport class ConversationManager {\n  constructor() {} //\n\n  /**\n   * Make a POST request to the Conversation Manager service endpoint to create or join a conversation.\n   * @param args\n   * @param conversationCode\n   * @param callback\n   * @param errorCallback\n   */\n\n\n  createOrJoin(args, conversationCode, cb, err) {\n    try {\n      Contracts.throwIfNullOrUndefined(args, \"args\");\n      const languageCode = args.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, ConversationTranslatorConfig.defaultLanguageCode);\n      const nickname = args.getProperty(PropertyId.ConversationTranslator_Name);\n      const endpointHost = args.getProperty(PropertyId.ConversationTranslator_Host, ConversationTranslatorConfig.host);\n      const correlationId = args.getProperty(PropertyId.ConversationTranslator_CorrelationId);\n      const subscriptionKey = args.getProperty(PropertyId.SpeechServiceConnection_Key);\n      const subscriptionRegion = args.getProperty(PropertyId.SpeechServiceConnection_Region);\n      const authToken = args.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n      Contracts.throwIfNullOrWhitespace(languageCode, \"languageCode\");\n      Contracts.throwIfNullOrWhitespace(nickname, \"nickname\");\n      Contracts.throwIfNullOrWhitespace(endpointHost, \"endpointHost\");\n      const queryParams = {};\n      queryParams[ConversationTranslatorConfig.params.apiVersion] = ConversationTranslatorConfig.apiVersion;\n      queryParams[ConversationTranslatorConfig.params.languageCode] = languageCode;\n      queryParams[ConversationTranslatorConfig.params.nickname] = nickname;\n      const headers = {};\n\n      if (correlationId) {\n        headers[ConversationTranslatorConfig.params.correlationId] = correlationId;\n      }\n\n      headers[ConversationTranslatorConfig.params.clientAppId] = ConversationTranslatorConfig.clientAppId;\n\n      if (conversationCode !== undefined) {\n        queryParams[ConversationTranslatorConfig.params.roomId] = conversationCode;\n      } else {\n        Contracts.throwIfNullOrUndefined(subscriptionRegion, ConversationTranslatorConfig.strings.authInvalidSubscriptionRegion);\n        headers[ConversationTranslatorConfig.params.subscriptionRegion] = subscriptionRegion;\n\n        if (subscriptionKey) {\n          headers[ConversationTranslatorConfig.params.subscriptionKey] = subscriptionKey;\n        } else if (authToken) {\n          headers[ConversationTranslatorConfig.params.authorization] = `Bearer ${authToken}`;\n        } else {\n          Contracts.throwIfNullOrUndefined(subscriptionKey, ConversationTranslatorConfig.strings.authInvalidSubscriptionKey);\n        }\n      }\n\n      const config = {};\n      config.headers = headers;\n      const endpoint = `https://${endpointHost}${ConversationTranslatorConfig.restPath}`; // TODO: support a proxy and certificate validation\n\n      request(\"post\", endpoint, queryParams, null, config, response => {\n        const requestId = extractHeaderValue(ConversationTranslatorConfig.params.requestId, response.headers);\n\n        if (!response.ok) {\n          if (!!err) {\n            // get the error\n            let errorMessage = ConversationTranslatorConfig.strings.invalidCreateJoinConversationResponse.replace(\"{status}\", response.status.toString());\n            let errMessageRaw;\n\n            try {\n              errMessageRaw = JSON.parse(response.data);\n              errorMessage += ` [${errMessageRaw.error.code}: ${errMessageRaw.error.message}]`;\n            } catch (e) {\n              errorMessage += ` [${response.data}]`;\n            }\n\n            if (requestId) {\n              errorMessage += ` ${requestId}`;\n            }\n\n            err(errorMessage);\n          }\n\n          return;\n        }\n\n        const conversation = JSON.parse(response.data);\n\n        if (conversation) {\n          conversation.requestId = requestId;\n        }\n\n        if (!!cb) {\n          try {\n            cb(conversation);\n          } catch (e) {\n            if (!!err) {\n              err(e);\n            }\n          }\n\n          cb = undefined;\n        }\n      });\n    } catch (error) {\n      if (!!err) {\n        if (error instanceof Error) {\n          const typedError = error;\n          err(typedError.name + \": \" + typedError.message);\n        } else {\n          err(error);\n        }\n      }\n    }\n  }\n  /**\n   * Make a DELETE request to the Conversation Manager service endpoint to leave the conversation.\n   * @param args\n   * @param sessionToken\n   * @param callback\n   */\n\n\n  leave(args, sessionToken, cb, err) {\n    try {\n      Contracts.throwIfNullOrUndefined(args, ConversationTranslatorConfig.strings.invalidArgs.replace(\"{arg}\", \"config\"));\n      Contracts.throwIfNullOrWhitespace(sessionToken, ConversationTranslatorConfig.strings.invalidArgs.replace(\"{arg}\", \"token\"));\n      const endpointHost = args.getProperty(PropertyId.ConversationTranslator_Host, ConversationTranslatorConfig.host);\n      const correlationId = args.getProperty(PropertyId.ConversationTranslator_CorrelationId);\n      const queryParams = {};\n      queryParams[ConversationTranslatorConfig.params.apiVersion] = ConversationTranslatorConfig.apiVersion;\n      queryParams[ConversationTranslatorConfig.params.sessionToken] = sessionToken;\n      const headers = {};\n\n      if (correlationId) {\n        headers[ConversationTranslatorConfig.params.correlationId] = correlationId;\n      }\n\n      const config = {};\n      config.headers = headers;\n      const endpoint = `https://${endpointHost}${ConversationTranslatorConfig.restPath}`; // TODO: support a proxy and certificate validation\n\n      request(\"delete\", endpoint, queryParams, null, config, response => {\n        if (!response.ok) {// ignore errors on delete\n        }\n\n        if (!!cb) {\n          try {\n            cb();\n          } catch (e) {\n            if (!!err) {\n              err(e);\n            }\n          }\n\n          cb = undefined;\n        }\n      });\n    } catch (error) {\n      if (!!err) {\n        if (error instanceof Error) {\n          const typedError = error;\n          err(typedError.name + \": \" + typedError.message);\n        } else {\n          err(error);\n        }\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["src/common.speech/Transcription/ConversationManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { IStringDictionary } from \"../../common/Exports\";\r\nimport { Contracts } from \"../../sdk/Contracts\";\r\nimport { PropertyCollection, PropertyId } from \"../../sdk/Exports\";\r\nimport { IConversationResponseError, IInternalConversation, IRequestOptions, IResponse } from \"./ConversationTranslatorInterfaces\";\r\nimport { ConversationTranslatorConfig, extractHeaderValue, request } from \"./ConversationUtils\";\r\n\r\nexport class ConversationManager {\r\n\r\n    constructor() {\r\n        //\r\n    }\r\n\r\n    /**\r\n     * Make a POST request to the Conversation Manager service endpoint to create or join a conversation.\r\n     * @param args\r\n     * @param conversationCode\r\n     * @param callback\r\n     * @param errorCallback\r\n     */\r\n    public createOrJoin(args: PropertyCollection, conversationCode: string, cb?: any, err?: any): void {\r\n\r\n        try {\r\n\r\n            Contracts.throwIfNullOrUndefined(args, \"args\");\r\n\r\n            const languageCode: string = args.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, ConversationTranslatorConfig.defaultLanguageCode);\r\n            const nickname: string = args.getProperty(PropertyId.ConversationTranslator_Name);\r\n            const endpointHost: string = args.getProperty(PropertyId.ConversationTranslator_Host, ConversationTranslatorConfig.host);\r\n            const correlationId: string = args.getProperty(PropertyId.ConversationTranslator_CorrelationId);\r\n            const subscriptionKey: string = args.getProperty(PropertyId.SpeechServiceConnection_Key);\r\n            const subscriptionRegion: string = args.getProperty(PropertyId.SpeechServiceConnection_Region);\r\n            const authToken: string = args.getProperty(PropertyId.SpeechServiceAuthorization_Token);\r\n\r\n            Contracts.throwIfNullOrWhitespace(languageCode, \"languageCode\");\r\n            Contracts.throwIfNullOrWhitespace(nickname, \"nickname\");\r\n            Contracts.throwIfNullOrWhitespace(endpointHost, \"endpointHost\");\r\n\r\n            const queryParams: IStringDictionary<string> = {};\r\n            queryParams[ConversationTranslatorConfig.params.apiVersion] = ConversationTranslatorConfig.apiVersion;\r\n            queryParams[ConversationTranslatorConfig.params.languageCode] = languageCode;\r\n            queryParams[ConversationTranslatorConfig.params.nickname] = nickname;\r\n\r\n            const headers: IStringDictionary<string> = {};\r\n            if (correlationId) {\r\n                headers[ConversationTranslatorConfig.params.correlationId] = correlationId;\r\n            }\r\n            headers[ConversationTranslatorConfig.params.clientAppId] = ConversationTranslatorConfig.clientAppId;\r\n\r\n            if (conversationCode !== undefined) {\r\n                queryParams[ConversationTranslatorConfig.params.roomId] = conversationCode;\r\n            } else {\r\n                Contracts.throwIfNullOrUndefined(subscriptionRegion, ConversationTranslatorConfig.strings.authInvalidSubscriptionRegion);\r\n                headers[ConversationTranslatorConfig.params.subscriptionRegion] = subscriptionRegion;\r\n                if (subscriptionKey) {\r\n                    headers[ConversationTranslatorConfig.params.subscriptionKey] = subscriptionKey;\r\n                } else if (authToken) {\r\n                    headers[ConversationTranslatorConfig.params.authorization] = `Bearer ${authToken}`;\r\n                } else {\r\n                    Contracts.throwIfNullOrUndefined(subscriptionKey, ConversationTranslatorConfig.strings.authInvalidSubscriptionKey);\r\n                }\r\n            }\r\n\r\n            const config: IRequestOptions = {};\r\n            config.headers = headers;\r\n\r\n            const endpoint: string = `https://${endpointHost}${ConversationTranslatorConfig.restPath}`;\r\n\r\n            // TODO: support a proxy and certificate validation\r\n            request(\"post\", endpoint, queryParams, null, config, (response: IResponse) => {\r\n\r\n                const requestId: string = extractHeaderValue(ConversationTranslatorConfig.params.requestId, response.headers);\r\n\r\n                if (!response.ok) {\r\n                    if (!!err) {\r\n                        // get the error\r\n                        let errorMessage: string = ConversationTranslatorConfig.strings.invalidCreateJoinConversationResponse.replace(\"{status}\", response.status.toString());\r\n                        let errMessageRaw: IConversationResponseError;\r\n                        try {\r\n                            errMessageRaw = JSON.parse(response.data) as IConversationResponseError;\r\n                            errorMessage += ` [${errMessageRaw.error.code}: ${errMessageRaw.error.message}]`;\r\n                        } catch (e) {\r\n                            errorMessage += ` [${response.data}]`;\r\n                        }\r\n                        if (requestId) {\r\n                            errorMessage += ` ${requestId}`;\r\n                        }\r\n\r\n                        err(errorMessage);\r\n                    }\r\n                    return;\r\n                }\r\n                const conversation: IInternalConversation = JSON.parse(response.data) as IInternalConversation;\r\n                if (conversation) {\r\n                    conversation.requestId = requestId;\r\n                }\r\n                if (!!cb) {\r\n                    try {\r\n                        cb(conversation);\r\n                    } catch (e) {\r\n                        if (!!err) {\r\n                            err(e);\r\n                        }\r\n                    }\r\n                    cb = undefined;\r\n                }\r\n\r\n            });\r\n\r\n        } catch (error) {\r\n            if (!!err) {\r\n                if (error instanceof Error) {\r\n                    const typedError: Error = error as Error;\r\n                    err(typedError.name + \": \" + typedError.message);\r\n\r\n                } else {\r\n                    err(error);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Make a DELETE request to the Conversation Manager service endpoint to leave the conversation.\r\n     * @param args\r\n     * @param sessionToken\r\n     * @param callback\r\n     */\r\n    public leave(args: PropertyCollection, sessionToken: string, cb?: any, err?: any): void {\r\n\r\n        try {\r\n\r\n            Contracts.throwIfNullOrUndefined(args, ConversationTranslatorConfig.strings.invalidArgs.replace(\"{arg}\", \"config\"));\r\n            Contracts.throwIfNullOrWhitespace(sessionToken, ConversationTranslatorConfig.strings.invalidArgs.replace(\"{arg}\", \"token\"));\r\n\r\n            const endpointHost: string = args.getProperty(PropertyId.ConversationTranslator_Host, ConversationTranslatorConfig.host);\r\n            const correlationId: string = args.getProperty(PropertyId.ConversationTranslator_CorrelationId);\r\n\r\n            const queryParams: IStringDictionary<string> = {};\r\n            queryParams[ConversationTranslatorConfig.params.apiVersion] = ConversationTranslatorConfig.apiVersion;\r\n            queryParams[ConversationTranslatorConfig.params.sessionToken] = sessionToken;\r\n\r\n            const headers: IStringDictionary<string> = {};\r\n            if (correlationId) {\r\n                headers[ConversationTranslatorConfig.params.correlationId] = correlationId;\r\n            }\r\n\r\n            const config: IRequestOptions = {};\r\n            config.headers = headers;\r\n\r\n            const endpoint: string = `https://${endpointHost}${ConversationTranslatorConfig.restPath}`;\r\n\r\n            // TODO: support a proxy and certificate validation\r\n            request(\"delete\", endpoint, queryParams, null, config, (response: IResponse) => {\r\n\r\n                if (!response.ok) {\r\n                    // ignore errors on delete\r\n                }\r\n\r\n                if (!!cb) {\r\n                    try {\r\n                        cb();\r\n                    } catch (e) {\r\n                        if (!!err) {\r\n                            err(e);\r\n                        }\r\n                    }\r\n                    cb = undefined;\r\n                }\r\n            });\r\n\r\n        } catch (error) {\r\n            if (!!err) {\r\n                if (error instanceof Error) {\r\n                    const typedError: Error = error as Error;\r\n                    err(typedError.name + \": \" + typedError.message);\r\n\r\n                } else {\r\n                    err(error);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}