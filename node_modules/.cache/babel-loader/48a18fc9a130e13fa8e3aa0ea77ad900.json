{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ConnectionState, createNoDashGuid, Deferred, MessageType, Promise, PromiseHelper } from \"../../common/Exports\";\nimport { Sink } from \"../../common/Promise\";\nimport { CancellationErrorCode, CancellationReason, ConversationExpirationEventArgs, ConversationTranslationCanceledEventArgs, ConversationTranslationResult, PropertyId, SessionEventArgs, Translations } from \"../../sdk/Exports\";\nimport { ServiceRecognizerBase } from \"../Exports\";\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\nimport { ConversationRequestSession } from \"./ConversationRequestSession\";\nimport { ConversationReceivedTranslationEventArgs, LockRoomEventArgs, MuteAllEventArgs, ParticipantAttributeEventArgs, ParticipantEventArgs, ParticipantsListEventArgs } from \"./ConversationTranslatorEventArgs\";\nimport { ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes } from \"./ConversationTranslatorInterfaces\";\nimport { CommandResponsePayload, ParticipantPayloadResponse, ParticipantsListPayloadResponse, SpeechResponsePayload, TextResponsePayload } from \"./ServiceMessages/Exports\";\n/***\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\n */\n\nexport class ConversationServiceAdapter extends ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\n    this.privLastPartialUtteranceId = \"\";\n\n    this.sendMessageAsync = message => {\n      const sink = new Sink();\n      this.fetchConversationConnection().continueWith(antecedent => {\n        try {\n          if (antecedent.isError) {\n            sink.reject(antecedent.error);\n          } else {\n            antecedent.result.send(new ConversationConnectionMessage(MessageType.Text, message)).continueWith(innerAntecedent => {\n              try {\n                if (innerAntecedent.isError) {\n                  sink.reject(innerAntecedent.error);\n                } else {\n                  sink.resolve(innerAntecedent.result);\n                }\n              } catch (e) {\n                sink.reject(`Unhandled inner error: ${e}`);\n              }\n            });\n          }\n        } catch (e) {\n          sink.reject(`Unhandled error: ${e}`);\n        }\n      });\n      return new Promise(sink);\n    };\n\n    this.noOp = () => {// operation not supported\n    };\n    /**\n     * Process incoming websocket messages\n     */\n\n\n    this.receiveConversationMessageOverride = (successCallback, errorCallBack) => {\n      // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n      const communicationCustodian = new Deferred();\n      this.fetchConversationConnection().on(connection => {\n        return connection.read().onSuccessContinueWithPromise(message => {\n          const isDisposed = this.isDisposed();\n          const terminateMessageLoop = !this.isDisposed() && this.terminateMessageLoop;\n          const sessionId = this.privConversationRequestSession.sessionId;\n          let sendFinal = false;\n\n          if (isDisposed || terminateMessageLoop) {\n            // We're done.\n            communicationCustodian.resolve(undefined);\n            return PromiseHelper.fromResult(undefined);\n          }\n\n          if (!message) {\n            return this.receiveConversationMessageOverride();\n          }\n\n          try {\n            switch (message.conversationMessageType.toLowerCase()) {\n              case \"info\":\n              case \"participant_command\":\n              case \"command\":\n                const commandPayload = CommandResponsePayload.fromJSON(message.textBody);\n\n                switch (commandPayload.command.toLowerCase()) {\n                  /**\n                   * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\n                   * The consuming client must wait for this message to arrive\n                   * before starting to send their own data.\n                   */\n                  case \"participantlist\":\n                    const participantsPayload = ParticipantsListPayloadResponse.fromJSON(message.textBody);\n                    const participantsResult = participantsPayload.participants.map(p => {\n                      const participant = {\n                        avatar: p.avatar,\n                        displayName: p.nickname,\n                        id: p.participantId,\n                        isHost: p.ishost,\n                        isMuted: p.ismuted,\n                        isUsingTts: p.usetts,\n                        preferredLanguage: p.locale\n                      };\n                      return participant;\n                    });\n\n                    if (!!this.privConversationServiceConnector.participantsListReceived) {\n                      this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token, participantsPayload.translateTo, participantsPayload.profanityFilter, participantsPayload.roomProfanityFilter, participantsPayload.roomLocked, participantsPayload.muteAll, participantsResult, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\n                   * This is sent at the start of the Conversation\n                   */\n\n                  case \"settranslatetolanguages\":\n                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                      this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setTranslateToLanguages, commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\n                   * If sent by the participant the setting will effect only their own profanity level.\n                   * If sent by the host, the setting will effect all participants including the host.\n                   * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\n                   */\n\n                  case \"setprofanityfiltering\":\n                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                      this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setProfanityFiltering, commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetMute' is sent if the participant has been muted by the host.\n                   * Check the 'participantId' to determine if the current user has been muted.\n                   */\n\n                  case \"setmute\":\n                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                      this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setMute, commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetMuteAll' is sent if the Conversation has been muted by the host.\n                   */\n\n                  case \"setmuteall\":\n                    if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\n                      this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new MuteAllEventArgs(commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\n                   */\n\n                  case \"roomexpirationwarning\":\n                    if (!!this.privConversationServiceConnector.conversationExpiration) {\n                      this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new ConversationExpirationEventArgs(commandPayload.value, this.privConversationRequestSession.sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\n                   */\n\n                  case \"setusetts\":\n                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                      this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setUseTTS, commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetLockState' is set if the host has locked or unlocked the Conversation.\n                   */\n\n                  case \"setlockstate\":\n                    if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\n                      this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new LockRoomEventArgs(commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'ChangeNickname' is received if a user changes their display name.\n                   * Any cached particpiants list should be updated to reflect the display name.\n                   */\n\n                  case \"changenickname\":\n                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                      this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.changeNickname, commandPayload.nickname, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'JoinSession' is sent when a user joins the Conversation.\n                   */\n\n                  case \"joinsession\":\n                    const joinParticipantPayload = ParticipantPayloadResponse.fromJSON(message.textBody);\n                    const joiningParticipant = {\n                      avatar: joinParticipantPayload.avatar,\n                      displayName: joinParticipantPayload.nickname,\n                      id: joinParticipantPayload.participantId,\n                      isHost: joinParticipantPayload.ishost,\n                      isMuted: joinParticipantPayload.ismuted,\n                      isUsingTts: joinParticipantPayload.usetts,\n                      preferredLanguage: joinParticipantPayload.locale\n                    };\n\n                    if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\n                      this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new ParticipantEventArgs(joiningParticipant, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'LeaveSession' is sent when a user leaves the Conversation'.\n                   */\n\n                  case \"leavesession\":\n                    const leavingParticipant = {\n                      id: commandPayload.participantId\n                    };\n\n                    if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\n                      this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new ParticipantEventArgs(leavingParticipant, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\n                   * Check the 'ParticipantId' to check whether the message is for the current user.\n                   */\n\n                  case \"disconnectsession\":\n                    const disconnectParticipant = {\n                      id: commandPayload.participantId\n                    };\n                    break;\n\n                  /**\n                   * Message not recognized.\n                   */\n\n                  default:\n                    break;\n                }\n\n                break;\n\n              /**\n               * 'partial' (or 'hypothesis') represents a unfinalized speech message.\n               */\n\n              case \"partial\":\n              /**\n               * 'final' (or 'phrase') represents a finalized speech message.\n               */\n\n              case \"final\":\n                const speechPayload = SpeechResponsePayload.fromJSON(message.textBody);\n                const speechResult = new ConversationTranslationResult(speechPayload.participantId, this.getTranslations(speechPayload.translations), speechPayload.language, undefined, undefined, speechPayload.recognition, undefined, undefined, message.textBody, undefined);\n\n                if (speechPayload.isFinal) {\n                  // check the length, sometimes empty finals are returned\n                  if (speechResult.text !== undefined && speechResult.text.length > 0) {\n                    sendFinal = true;\n                  } else if (speechPayload.id === this.privLastPartialUtteranceId) {\n                    // send final as normal. We had a non-empty partial for this same utterance\n                    // so sending the empty final is important\n                    sendFinal = true;\n                  } else {// suppress unneeded final\n                  }\n\n                  if (sendFinal) {\n                    if (!!this.privConversationServiceConnector.translationReceived) {\n                      this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\n                    }\n                  }\n                } else if (speechResult.text !== undefined) {\n                  this.privLastPartialUtteranceId = speechPayload.id;\n\n                  if (!!this.privConversationServiceConnector.translationReceived) {\n                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\n                  }\n                }\n\n                break;\n\n              /**\n               * \"translated_message\" is a text message or instant message (IM).\n               */\n\n              case \"translated_message\":\n                const textPayload = TextResponsePayload.fromJSON(message.textBody);\n                const textResult = new ConversationTranslationResult(textPayload.participantId, this.getTranslations(textPayload.translations), textPayload.language, undefined, undefined, textPayload.originalText, undefined, undefined, undefined, message.textBody, undefined);\n\n                if (!!this.privConversationServiceConnector.translationReceived) {\n                  this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\n                }\n\n                break;\n\n              default:\n                // ignore any unsupported message types\n                break;\n            }\n          } catch (e) {// continue\n          }\n\n          return this.receiveConversationMessageOverride();\n        });\n      }, error => {\n        this.terminateMessageLoop = true;\n      });\n      return communicationCustodian.promise();\n    };\n\n    this.fetchConversationConnection = () => {\n      return this.configConnection();\n    };\n\n    this.privConversationServiceConnector = conversationServiceConnector;\n    this.privConversationAuthentication = authentication;\n    this.receiveMessageOverride = this.receiveConversationMessageOverride;\n    this.recognizeOverride = this.noOp;\n    this.connectImplOverride = this.conversationConnectImpl;\n    this.configConnectionOverride = this.configConnection;\n    this.fetchConnectionOverride = this.fetchConversationConnection;\n    this.disconnectOverride = this.privDisconnect;\n    this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\n    this.privConversationConnectionFactory = connectionFactory;\n    this.privConversationIsDisposed = false;\n  }\n\n  isDisposed() {\n    return this.privConversationIsDisposed;\n  }\n\n  dispose(reason) {\n    this.privConversationIsDisposed = true;\n\n    if (this.privConnectionConfigPromise) {\n      this.privConnectionConfigPromise.onSuccessContinueWith(connection => {\n        connection.dispose(reason);\n      });\n    }\n  }\n\n  sendMessage(message) {\n    this.fetchConversationConnection().onSuccessContinueWith(connection => {\n      connection.send(new ConversationConnectionMessage(MessageType.Text, message));\n    });\n  }\n\n  privDisconnect() {\n    if (this.terminateMessageLoop) {\n      return;\n    }\n\n    this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.NoError, \"Disconnecting\");\n    this.terminateMessageLoop = true;\n\n    if (this.privConversationConnectionPromise.result().isCompleted) {\n      if (!this.privConversationConnectionPromise.result().isError) {\n        this.privConversationConnectionPromise.result().result.dispose();\n        this.privConversationConnectionPromise = null;\n      }\n    } else {\n      this.privConversationConnectionPromise.onSuccessContinueWith(connection => {\n        connection.dispose();\n      });\n    }\n  }\n\n  processTypeSpecificMessages(connectionMessage, successCallback, errorCallBack) {\n    return true;\n  } // Cancels recognition.\n\n\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    this.terminateMessageLoop = true;\n    const cancelEvent = new ConversationTranslationCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n\n    try {\n      if (!!this.privConversationServiceConnector.canceled) {\n        this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\n      }\n    } catch (_a) {// continue on error\n    }\n  }\n  /**\n   * Establishes a websocket connection to the end point.\n   * @param isUnAuthorized\n   */\n\n\n  conversationConnectImpl(isUnAuthorized = false) {\n    if (this.privConversationConnectionPromise) {\n      if (this.privConversationConnectionPromise.result().isCompleted && (this.privConversationConnectionPromise.result().isError || this.privConversationConnectionPromise.result().result.state() === ConnectionState.Disconnected)) {\n        this.privConnectionId = null;\n        this.privConversationConnectionPromise = null;\n        this.terminateMessageLoop = true;\n        return this.conversationConnectImpl();\n      } else {\n        return this.privConversationConnectionPromise;\n      }\n    }\n\n    this.privConversationAuthFetchEventId = createNoDashGuid(); // keep the connectionId for reconnect events\n\n    if (this.privConnectionId === undefined) {\n      this.privConnectionId = createNoDashGuid();\n    }\n\n    this.privConversationRequestSession.onPreConnectionStart(this.privConversationAuthFetchEventId, this.privConnectionId);\n    const authPromise = isUnAuthorized ? this.privConversationAuthentication.fetchOnExpiry(this.privConversationAuthFetchEventId) : this.privConversationAuthentication.fetch(this.privConversationAuthFetchEventId);\n    this.privConversationConnectionPromise = authPromise.continueWithPromise(result => {\n      if (result.isError) {\n        this.privConversationRequestSession.onAuthCompleted(true, result.error);\n        throw new Error(result.error);\n      } else {\n        this.privConversationRequestSession.onAuthCompleted(false);\n      }\n\n      const connection = this.privConversationConnectionFactory.create(this.privRecognizerConfig, result.result, this.privConnectionId); // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\n      // it'll stop sending events.\n\n      connection.events.attach(event => {\n        this.connectionEvents.onEvent(event);\n      });\n      return connection.open().onSuccessContinueWithPromise(response => {\n        if (response.statusCode === 200) {\n          this.privConversationRequestSession.onPreConnectionStart(this.privConversationAuthFetchEventId, this.privConnectionId);\n          this.privConversationRequestSession.onConnectionEstablishCompleted(response.statusCode);\n          const sessionStartEventArgs = new SessionEventArgs(this.privConversationRequestSession.sessionId);\n\n          if (!!this.privConversationServiceConnector.connectionOpened) {\n            this.privConversationServiceConnector.connectionOpened(this.privConversationServiceConnector, sessionStartEventArgs);\n          }\n\n          return PromiseHelper.fromResult(connection);\n        } else if (response.statusCode === 403 && !isUnAuthorized) {\n          return this.conversationConnectImpl(true);\n        } else {\n          this.privConversationRequestSession.onConnectionEstablishCompleted(response.statusCode, response.reason);\n          return PromiseHelper.fromError(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\n        }\n      });\n    });\n    this.privConnectionLoop = this.startMessageLoop();\n    return this.privConversationConnectionPromise;\n  }\n\n  startMessageLoop() {\n    this.terminateMessageLoop = false;\n    const messageRetrievalPromise = this.receiveConversationMessageOverride();\n    return messageRetrievalPromise.on(r => {\n      return true;\n    }, error => {\n      this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : \"\", this.privRequestSession ? this.privRequestSession.requestId : \"\", CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n    });\n  } // Takes an established websocket connection to the endpoint\n\n\n  configConnection() {\n    if (this.privConnectionConfigPromise) {\n      if (this.privConnectionConfigPromise.result().isCompleted && (this.privConnectionConfigPromise.result().isError || this.privConnectionConfigPromise.result().result.state() === ConnectionState.Disconnected)) {\n        this.privConnectionConfigPromise = null;\n        return this.configConnection();\n      } else {\n        return this.privConnectionConfigPromise;\n      }\n    }\n\n    if (this.terminateMessageLoop) {\n      return PromiseHelper.fromResult(undefined);\n    }\n\n    this.privConnectionConfigPromise = this.conversationConnectImpl().onSuccessContinueWith(connection => {\n      return connection;\n    });\n    return this.privConnectionConfigPromise;\n  }\n\n  getTranslations(serviceResultTranslations) {\n    let translations;\n\n    if (undefined !== serviceResultTranslations) {\n      translations = new Translations();\n\n      for (const translation of serviceResultTranslations) {\n        translations.set(translation.lang, translation.translation);\n      }\n    }\n\n    return translations;\n  }\n\n}","map":{"version":3,"sources":["src/common.speech/Transcription/ConversationServiceAdapter.ts"],"names":[],"mappings":"AAAA;AACA;AAEA,SAII,eAJJ,EAKI,gBALJ,EAMI,QANJ,EASI,WATJ,EAUI,OAVJ,EAWI,aAXJ,QAaO,sBAbP;AAcA,SAAS,IAAT,QAAqB,sBAArB;AACA,SACI,qBADJ,EAEI,kBAFJ,EAGI,+BAHJ,EAII,wCAJJ,EAKI,6BALJ,EAMI,UANJ,EAOI,gBAPJ,EASI,YATJ,QAUO,mBAVP;AAWA,SACqE,qBADrE,QAEO,YAFP;AAGA,SAAS,6BAAT,QAA8C,iCAA9C;AACA,SAAS,0BAAT,QAA2C,8BAA3C;AACA,SACI,wCADJ,EAEI,iBAFJ,EAGI,gBAHJ,EAII,6BAJJ,EAKI,oBALJ,EAMI,yBANJ,QAMqC,mCANrC;AAOA,SAAS,kCAAT,EAA6C,kCAA7C,QAA6G,oCAA7G;AAEA,SACI,sBADJ,EAKI,0BALJ,EAMI,+BANJ,EAOI,qBAPJ,EAQI,mBARJ,QAQgC,2BARhC;AAUA;;;;AAGA,OAAM,MAAO,0BAAP,SAA0C,qBAA1C,CAA+D;AAajE,EAAA,WAAA,CACI,cADJ,EAEI,iBAFJ,EAGI,WAHJ,EAII,gBAJJ,EAKI,4BALJ,EAKkE;AAE9D,UAAM,cAAN,EAAsB,iBAAtB,EAAyC,WAAzC,EAAsD,gBAAtD,EAAwE,4BAAxE;AAVI,SAAA,0BAAA,GAAqC,EAArC;;AA8CD,SAAA,gBAAA,GAAoB,OAAD,IAAsC;AAC5D,YAAM,IAAI,GAAkB,IAAI,IAAJ,EAA5B;AAEA,WAAK,2BAAL,GAAmC,YAAnC,CAAiD,UAAD,IAAiD;AAC7F,YAAI;AACA,cAAI,UAAU,CAAC,OAAf,EAAwB;AACpB,YAAA,IAAI,CAAC,MAAL,CAAY,UAAU,CAAC,KAAvB;AACH,WAFD,MAEO;AACH,YAAA,UAAU,CAAC,MAAX,CAAkB,IAAlB,CAAuB,IAAI,6BAAJ,CAAkC,WAAW,CAAC,IAA9C,EAAoD,OAApD,CAAvB,EACK,YADL,CACmB,eAAD,IAAkD;AAC5D,kBAAI;AACA,oBAAI,eAAe,CAAC,OAApB,EAA6B;AACzB,kBAAA,IAAI,CAAC,MAAL,CAAY,eAAe,CAAC,KAA5B;AACH,iBAFD,MAEO;AACH,kBAAA,IAAI,CAAC,OAAL,CAAa,eAAe,CAAC,MAA7B;AACH;AACJ,eAND,CAME,OAAO,CAAP,EAAU;AACR,gBAAA,IAAI,CAAC,MAAL,CAAY,0BAA0B,CAAC,EAAvC;AACH;AACJ,aAXL;AAYH;AACJ,SAjBD,CAiBE,OAAO,CAAP,EAAU;AACR,UAAA,IAAI,CAAC,MAAL,CAAY,oBAAoB,CAAC,EAAjC;AACH;AACJ,OArBD;AAuBA,aAAO,IAAI,OAAJ,CAAqB,IAArB,CAAP;AACH,KA3BM;;AAqFG,SAAA,IAAA,GAAO,MAAU,CACvB;AACH,KAFS;AAyEV;;;;;AAGQ,SAAA,kCAAA,GAAqC,CACzC,eADyC,EAEzC,aAFyC,KAGf;AAEtB;AACA,YAAM,sBAAsB,GAA0B,IAAI,QAAJ,EAAtD;AAEA,WAAK,2BAAL,GAAmC,EAAnC,CAAuC,UAAD,IAAkD;AACpF,eAAO,UAAU,CAAC,IAAX,GACF,4BADE,CAC4B,OAAD,IAAiE;AAC3F,gBAAM,UAAU,GAAY,KAAK,UAAL,EAA5B;AACA,gBAAM,oBAAoB,GAAI,CAAC,KAAK,UAAL,EAAD,IAAsB,KAAK,oBAAzD;AACA,gBAAM,SAAS,GAAW,KAAK,8BAAL,CAAoC,SAA9D;AACA,cAAI,SAAS,GAAY,KAAzB;;AACA,cAAI,UAAU,IAAI,oBAAlB,EAAwC;AACpC;AACA,YAAA,sBAAsB,CAAC,OAAvB,CAA+B,SAA/B;AACA,mBAAO,aAAa,CAAC,UAAd,CAAsC,SAAtC,CAAP;AACH;;AAED,cAAI,CAAC,OAAL,EAAc;AACV,mBAAO,KAAK,kCAAL,EAAP;AACH;;AAED,cAAI;AACA,oBAAQ,OAAO,CAAC,uBAAR,CAAgC,WAAhC,EAAR;AACI,mBAAK,MAAL;AACA,mBAAK,qBAAL;AACA,mBAAK,SAAL;AACI,sBAAM,cAAc,GAA2B,sBAAsB,CAAC,QAAvB,CAAgC,OAAO,CAAC,QAAxC,CAA/C;;AACA,wBAAQ,cAAc,CAAC,OAAf,CAAuB,WAAvB,EAAR;AAEI;;;;;AAKA,uBAAK,iBAAL;AAEI,0BAAM,mBAAmB,GAAqC,+BAA+B,CAAC,QAAhC,CAAyC,OAAO,CAAC,QAAjD,CAA9D;AAEA,0BAAM,kBAAkB,GAA2B,mBAAmB,CAAC,YAApB,CAAiC,GAAjC,CAAsC,CAAD,IAAmC;AACvH,4BAAM,WAAW,GAA0B;AACvC,wBAAA,MAAM,EAAE,CAAC,CAAC,MAD6B;AAEvC,wBAAA,WAAW,EAAE,CAAC,CAAC,QAFwB;AAGvC,wBAAA,EAAE,EAAE,CAAC,CAAC,aAHiC;AAIvC,wBAAA,MAAM,EAAE,CAAC,CAAC,MAJ6B;AAKvC,wBAAA,OAAO,EAAE,CAAC,CAAC,OAL4B;AAMvC,wBAAA,UAAU,EAAE,CAAC,CAAC,MANyB;AAOvC,wBAAA,iBAAiB,EAAE,CAAC,CAAC;AAPkB,uBAA3C;AASA,6BAAO,WAAP;AACH,qBAXkD,CAAnD;;AAaA,wBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,wBAA5C,EAAsE;AAClE,2BAAK,gCAAL,CAAsC,wBAAtC,CAA+D,KAAK,gCAApE,EACI,IAAI,yBAAJ,CAA8B,mBAAmB,CAAC,MAAlD,EAA0D,mBAAmB,CAAC,KAA9E,EACI,mBAAmB,CAAC,WADxB,EACqC,mBAAmB,CAAC,eADzD,EAEI,mBAAmB,CAAC,mBAFxB,EAE6C,mBAAmB,CAAC,UAFjE,EAGI,mBAAmB,CAAC,OAHxB,EAGiC,kBAHjC,EAGqD,SAHrD,CADJ;AAKH;;AACD;;AAEJ;;;;;AAIA,uBAAK,yBAAL;AAEI,wBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,gCAA5C,EAA8E;AAC1E,2BAAK,gCAAL,CAAsC,gCAAtC,CAAuE,KAAK,gCAA5E,EACI,IAAI,6BAAJ,CAAkC,cAAc,CAAC,aAAjD,EACI,kCAAkC,CAAC,uBADvC,EAEI,cAAc,CAAC,KAFnB,EAE0B,SAF1B,CADJ;AAIH;;AAED;;AAEJ;;;;;;;AAMA,uBAAK,uBAAL;AAEI,wBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,gCAA5C,EAA8E;AAC1E,2BAAK,gCAAL,CAAsC,gCAAtC,CAAuE,KAAK,gCAA5E,EACI,IAAI,6BAAJ,CAAkC,cAAc,CAAC,aAAjD,EACI,kCAAkC,CAAC,qBADvC,EAEI,cAAc,CAAC,KAFnB,EAE0B,SAF1B,CADJ;AAIH;;AAED;;AAEJ;;;;;AAIA,uBAAK,SAAL;AAEI,wBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,gCAA5C,EAA8E;AAC1E,2BAAK,gCAAL,CAAsC,gCAAtC,CAAuE,KAAK,gCAA5E,EACI,IAAI,6BAAJ,CAAkC,cAAc,CAAC,aAAjD,EACI,kCAAkC,CAAC,OADvC,EAEI,cAAc,CAAC,KAFnB,EAE0B,SAF1B,CADJ;AAIH;;AAED;;AAEJ;;;;AAGA,uBAAK,YAAL;AAEI,wBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,sBAA5C,EAAoE;AAChE,2BAAK,gCAAL,CAAsC,sBAAtC,CAA6D,KAAK,gCAAlE,EACI,IAAI,gBAAJ,CAAqB,cAAc,CAAC,KAApC,EAAsD,SAAtD,CADJ;AAEH;;AAED;;AAEJ;;;;AAGA,uBAAK,uBAAL;AAEI,wBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,sBAA5C,EAAoE;AAChE,2BAAK,gCAAL,CAAsC,sBAAtC,CAA6D,KAAK,gCAAlE,EACI,IAAI,+BAAJ,CAAoC,cAAc,CAAC,KAAnD,EAAoE,KAAK,8BAAL,CAAoC,SAAxG,CADJ;AAEH;;AAED;;AAEJ;;;;AAGA,uBAAK,WAAL;AAEI,wBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,gCAA5C,EAA8E;AAC1E,2BAAK,gCAAL,CAAsC,gCAAtC,CAAuE,KAAK,gCAA5E,EACI,IAAI,6BAAJ,CAAkC,cAAc,CAAC,aAAjD,EACI,kCAAkC,CAAC,SADvC,EAEI,cAAc,CAAC,KAFnB,EAE0B,SAF1B,CADJ;AAIH;;AAED;;AAEJ;;;;AAGA,uBAAK,cAAL;AAEI,wBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,uBAA5C,EAAqE;AACjE,2BAAK,gCAAL,CAAsC,uBAAtC,CAA8D,KAAK,gCAAnE,EACI,IAAI,iBAAJ,CAAsB,cAAc,CAAC,KAArC,EAAuD,SAAvD,CADJ;AAEH;;AAED;;AAEJ;;;;;AAIA,uBAAK,gBAAL;AAEI,wBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,gCAA5C,EAA8E;AAC1E,2BAAK,gCAAL,CAAsC,gCAAtC,CAAuE,KAAK,gCAA5E,EACI,IAAI,6BAAJ,CAAkC,cAAc,CAAC,aAAjD,EACI,kCAAkC,CAAC,cADvC,EAEI,cAAc,CAAC,QAFnB,EAE6B,SAF7B,CADJ;AAIH;;AAED;;AAEJ;;;;AAGA,uBAAK,aAAL;AAEI,0BAAM,sBAAsB,GAA+B,0BAA0B,CAAC,QAA3B,CAAoC,OAAO,CAAC,QAA5C,CAA3D;AAEA,0BAAM,kBAAkB,GAAyB;AAC7C,sBAAA,MAAM,EAAE,sBAAsB,CAAC,MADc;AAE7C,sBAAA,WAAW,EAAE,sBAAsB,CAAC,QAFS;AAG7C,sBAAA,EAAE,EAAE,sBAAsB,CAAC,aAHkB;AAI7C,sBAAA,MAAM,EAAE,sBAAsB,CAAC,MAJc;AAK7C,sBAAA,OAAO,EAAE,sBAAsB,CAAC,OALa;AAM7C,sBAAA,UAAU,EAAE,sBAAsB,CAAC,MANU;AAO7C,sBAAA,iBAAiB,EAAE,sBAAsB,CAAC;AAPG,qBAAjD;;AAUA,wBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,8BAA5C,EAA4E;AACxE,2BAAK,gCAAL,CAAsC,8BAAtC,CAAqE,KAAK,gCAA1E,EACI,IAAI,oBAAJ,CACI,kBADJ,EAEI,SAFJ,CADJ;AAIH;;AAED;;AAEJ;;;;AAGA,uBAAK,cAAL;AAEI,0BAAM,kBAAkB,GAAyB;AAC7C,sBAAA,EAAE,EAAE,cAAc,CAAC;AAD0B,qBAAjD;;AAIA,wBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,+BAA5C,EAA6E;AACzE,2BAAK,gCAAL,CAAsC,+BAAtC,CAAsE,KAAK,gCAA3E,EACI,IAAI,oBAAJ,CAAyB,kBAAzB,EAA6C,SAA7C,CADJ;AAEH;;AAED;;AAEJ;;;;;AAIA,uBAAK,mBAAL;AAEI,0BAAM,qBAAqB,GAAyB;AAChD,sBAAA,EAAE,EAAE,cAAc,CAAC;AAD6B,qBAApD;AAIA;;AAEJ;;;;AAGA;AACI;AA3MR;;AA6MA;;AAEJ;;;;AAGA,mBAAK,SAAL;AAEA;;;;AAGA,mBAAK,OAAL;AAEI,sBAAM,aAAa,GAA0B,qBAAqB,CAAC,QAAtB,CAA+B,OAAO,CAAC,QAAvC,CAA7C;AAEA,sBAAM,YAAY,GAAkC,IAAI,6BAAJ,CAAkC,aAAa,CAAC,aAAhD,EAChD,KAAK,eAAL,CAAqB,aAAa,CAAC,YAAnC,CADgD,EAEhD,aAAa,CAAC,QAFkC,EAGhD,SAHgD,EAIhD,SAJgD,EAKhD,aAAa,CAAC,WALkC,EAMhD,SANgD,EAOhD,SAPgD,EAQhD,OAAO,CAAC,QARwC,EAShD,SATgD,CAApD;;AAWA,oBAAI,aAAa,CAAC,OAAlB,EAA2B;AACvB;AACA,sBAAI,YAAY,CAAC,IAAb,KAAsB,SAAtB,IAAmC,YAAY,CAAC,IAAb,CAAkB,MAAlB,GAA2B,CAAlE,EAAqE;AACjE,oBAAA,SAAS,GAAG,IAAZ;AACH,mBAFD,MAEO,IAAI,aAAa,CAAC,EAAd,KAAqB,KAAK,0BAA9B,EAA0D;AAC7D;AACA;AACA,oBAAA,SAAS,GAAG,IAAZ;AACH,mBAJM,MAIA,CACH;AACH;;AAED,sBAAI,SAAJ,EAAe;AACX,wBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,mBAA5C,EAAiE;AAC7D,2BAAK,gCAAL,CAAsC,mBAAtC,CAA0D,KAAK,gCAA/D,EACI,IAAI,wCAAJ,CAA6C,kCAAkC,CAAC,KAAhF,EAAuF,YAAvF,EAAqG,SAArG,CADJ;AAEH;AACJ;AACJ,iBAlBD,MAkBQ,IAAI,YAAY,CAAC,IAAb,KAAsB,SAA1B,EAAqC;AACzC,uBAAK,0BAAL,GAAkC,aAAa,CAAC,EAAhD;;AACA,sBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,mBAA5C,EAAiE;AAC7D,yBAAK,gCAAL,CAAsC,mBAAtC,CAA0D,KAAK,gCAA/D,EACI,IAAI,wCAAJ,CAA6C,kCAAkC,CAAC,OAAhF,EAAyF,YAAzF,EAAuG,SAAvG,CADJ;AAEH;AACJ;;AAED;;AAEJ;;;;AAGA,mBAAK,oBAAL;AAEI,sBAAM,WAAW,GAAwB,mBAAmB,CAAC,QAApB,CAA6B,OAAO,CAAC,QAArC,CAAzC;AAEA,sBAAM,UAAU,GAAkC,IAAI,6BAAJ,CAAkC,WAAW,CAAC,aAA9C,EACtC,KAAK,eAAL,CAAqB,WAAW,CAAC,YAAjC,CADsC,EAEtC,WAAW,CAAC,QAF0B,EAGtC,SAHsC,EAItC,SAJsC,EAKtC,WAAW,CAAC,YAL0B,EAMtC,SANsC,EAOtC,SAPsC,EAQtC,SARsC,EAStC,OAAO,CAAC,QAT8B,EAUtC,SAVsC,CAAlD;;AAYA,oBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,mBAA5C,EAAiE;AAC7D,uBAAK,gCAAL,CAAsC,mBAAtC,CAA0D,KAAK,gCAA/D,EACI,IAAI,wCAAJ,CAA6C,kCAAkC,CAAC,cAAhF,EAAgG,UAAhG,EAA4G,SAA5G,CADJ;AAEH;;AACD;;AAEJ;AACI;AACA;AAlSR;AAoSH,WArSD,CAqSE,OAAO,CAAP,EAAU,CACR;AACH;;AACD,iBAAO,KAAK,kCAAL,EAAP;AACP,SAzTM,CAAP;AA0TH,OA3TD,EA2TI,KAAD,IAAkB;AACjB,aAAK,oBAAL,GAA4B,IAA5B;AACH,OA7TD;AA+TA,aAAO,sBAAsB,CAAC,OAAvB,EAAP;AACH,KAxUG;;AAkYA,SAAA,2BAAA,GAA8B,MAA2B;AAC7D,aAAO,KAAK,gBAAL,EAAP;AACH,KAFO;;AArkBJ,SAAK,gCAAL,GAAwC,4BAAxC;AACA,SAAK,8BAAL,GAAsC,cAAtC;AACA,SAAK,sBAAL,GAA8B,KAAK,kCAAnC;AACA,SAAK,iBAAL,GAAyB,KAAK,IAA9B;AACA,SAAK,mBAAL,GAA2B,KAAK,uBAAhC;AACA,SAAK,wBAAL,GAAgC,KAAK,gBAArC;AACA,SAAK,uBAAL,GAA+B,KAAK,2BAApC;AACA,SAAK,kBAAL,GAA0B,KAAK,cAA/B;AACA,SAAK,8BAAL,GAAsC,IAAI,0BAAJ,CAA+B,gBAAgB,EAA/C,CAAtC;AACA,SAAK,iCAAL,GAAyC,iBAAzC;AACA,SAAK,0BAAL,GAAkC,KAAlC;AACH;;AAEM,EAAA,UAAU,GAAA;AACb,WAAO,KAAK,0BAAZ;AACH;;AAEM,EAAA,OAAO,CAAC,MAAD,EAAgB;AAC1B,SAAK,0BAAL,GAAkC,IAAlC;;AACA,QAAI,KAAK,2BAAT,EAAsC;AAClC,WAAK,2BAAL,CAAiC,qBAAjC,CAAwD,UAAD,IAA4B;AAC/E,QAAA,UAAU,CAAC,OAAX,CAAmB,MAAnB;AACH,OAFD;AAGH;AACJ;;AAEM,EAAA,WAAW,CAAC,OAAD,EAAgB;AAC9B,SAAK,2BAAL,GAAmC,qBAAnC,CAA0D,UAAD,IAA4B;AACrF,MAAA,UAAU,CAAC,IAAX,CAAgB,IAAI,6BAAJ,CAChB,WAAW,CAAC,IADI,EAEhB,OAFgB,CAAhB;AAGC,KAJD;AAKH;;AA+BS,EAAA,cAAc,GAAA;AACpB,QAAI,KAAK,oBAAT,EAA+B;AAC3B;AACH;;AACD,SAAK,iBAAL,CAAuB,KAAK,8BAAL,CAAoC,SAA3D,EACI,KAAK,8BAAL,CAAoC,SADxC,EAEI,kBAAkB,CAAC,KAFvB,EAGI,qBAAqB,CAAC,OAH1B,EAII,eAJJ;AAMA,SAAK,oBAAL,GAA4B,IAA5B;;AACA,QAAI,KAAK,iCAAL,CAAuC,MAAvC,GAAgD,WAApD,EAAiE;AAC7D,UAAI,CAAC,KAAK,iCAAL,CAAuC,MAAvC,GAAgD,OAArD,EAA8D;AAC1D,aAAK,iCAAL,CAAuC,MAAvC,GAAgD,MAAhD,CAAuD,OAAvD;AACA,aAAK,iCAAL,GAAyC,IAAzC;AACH;AACJ,KALD,MAKO;AACH,WAAK,iCAAL,CAAuC,qBAAvC,CAA8D,UAAD,IAA4B;AACrF,QAAA,UAAU,CAAC,OAAX;AACH,OAFD;AAGH;AACJ;;AAES,EAAA,2BAA2B,CACjC,iBADiC,EAEjC,eAFiC,EAGjC,aAHiC,EAGE;AAC/B,WAAO,IAAP;AACP,GAjHgE,CAmHjE;;;AACU,EAAA,iBAAiB,CACvB,SADuB,EAEvB,SAFuB,EAGvB,kBAHuB,EAIvB,SAJuB,EAKvB,KALuB,EAKV;AAET,SAAK,oBAAL,GAA4B,IAA5B;AAEA,UAAM,WAAW,GAA6C,IAAI,wCAAJ,CAClD,kBADkD,EAElD,KAFkD,EAGlD,SAHkD,EAIlD,SAJkD,EAKlD,SALkD,CAA9D;;AAOA,QAAI;AACA,UAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,QAA5C,EAAsD;AAClD,aAAK,gCAAL,CAAsC,QAAtC,CAA+C,KAAK,gCAApD,EAAsF,WAAtF;AACH;AACJ,KAJD,CAIE,OAAA,EAAA,EAAM,CACJ;AACH;AACR;AAMD;;;;;;AAIU,EAAA,uBAAuB,CAAC,cAAA,GAA0B,KAA3B,EAAgC;AAE7D,QAAI,KAAK,iCAAT,EAA4C;AACxC,UAAI,KAAK,iCAAL,CAAuC,MAAvC,GAAgD,WAAhD,KACC,KAAK,iCAAL,CAAuC,MAAvC,GAAgD,OAAhD,IACM,KAAK,iCAAL,CAAuC,MAAvC,GAAgD,MAAhD,CAAuD,KAAvD,OAAmE,eAAe,CAAC,YAF1F,CAAJ,EAE6G;AACzG,aAAK,gBAAL,GAAwB,IAAxB;AACA,aAAK,iCAAL,GAAyC,IAAzC;AACA,aAAK,oBAAL,GAA4B,IAA5B;AACA,eAAO,KAAK,uBAAL,EAAP;AACH,OAPD,MAOO;AACH,eAAO,KAAK,iCAAZ;AACH;AACJ;;AAED,SAAK,gCAAL,GAAwC,gBAAgB,EAAxD,CAf6D,CAiB7D;;AACA,QAAI,KAAK,gBAAL,KAA0B,SAA9B,EAAyC;AACrC,WAAK,gBAAL,GAAwB,gBAAgB,EAAxC;AACH;;AAED,SAAK,8BAAL,CAAoC,oBAApC,CAAyD,KAAK,gCAA9D,EAAgG,KAAK,gBAArG;AAEA,UAAM,WAAW,GAAG,cAAc,GAAG,KAAK,8BAAL,CAAoC,aAApC,CAAkD,KAAK,gCAAvD,CAAH,GAA8F,KAAK,8BAAL,CAAoC,KAApC,CAA0C,KAAK,gCAA/C,CAAhI;AAEA,SAAK,iCAAL,GAAyC,WAAW,CAC/C,mBADoC,CACf,MAAD,IAAoC;AACrD,UAAI,MAAM,CAAC,OAAX,EAAoB;AAChB,aAAK,8BAAL,CAAoC,eAApC,CAAoD,IAApD,EAA0D,MAAM,CAAC,KAAjE;AACA,cAAM,IAAI,KAAJ,CAAU,MAAM,CAAC,KAAjB,CAAN;AACH,OAHD,MAGO;AACH,aAAK,8BAAL,CAAoC,eAApC,CAAoD,KAApD;AACH;;AAED,YAAM,UAAU,GAAgB,KAAK,iCAAL,CAAuC,MAAvC,CAA8C,KAAK,oBAAnD,EAAyE,MAAM,CAAC,MAAhF,EAAwF,KAAK,gBAA7F,CAAhC,CARqD,CAUrD;AACA;;AACA,MAAA,UAAU,CAAC,MAAX,CAAkB,MAAlB,CAA0B,KAAD,IAA2B;AAChD,aAAK,gBAAL,CAAsB,OAAtB,CAA8B,KAA9B;AACH,OAFD;AAIA,aAAO,UAAU,CAAC,IAAX,GAAkB,4BAAlB,CAAgD,QAAD,IAA2D;AAC7G,YAAI,QAAQ,CAAC,UAAT,KAAwB,GAA5B,EAAiC;AAC7B,eAAK,8BAAL,CAAoC,oBAApC,CAAyD,KAAK,gCAA9D,EAAgG,KAAK,gBAArG;AACA,eAAK,8BAAL,CAAoC,8BAApC,CAAmE,QAAQ,CAAC,UAA5E;AACA,gBAAM,qBAAqB,GAAqB,IAAI,gBAAJ,CAAqB,KAAK,8BAAL,CAAoC,SAAzD,CAAhD;;AACA,cAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,gBAA5C,EAA8D;AAC1D,iBAAK,gCAAL,CAAsC,gBAAtC,CAAuD,KAAK,gCAA5D,EAA8F,qBAA9F;AACH;;AACD,iBAAO,aAAa,CAAC,UAAd,CAAsC,UAAtC,CAAP;AACH,SARD,MAQO,IAAI,QAAQ,CAAC,UAAT,KAAwB,GAAxB,IAA+B,CAAC,cAApC,EAAoD;AACvD,iBAAO,KAAK,uBAAL,CAA6B,IAA7B,CAAP;AACH,SAFM,MAEA;AACH,eAAK,8BAAL,CAAoC,8BAApC,CAAmE,QAAQ,CAAC,UAA5E,EAAwF,QAAQ,CAAC,MAAjG;AACA,iBAAO,aAAa,CAAC,SAAd,CAAqC,yCAAyC,QAAQ,CAAC,UAAU,KAAK,KAAK,oBAAL,CAA0B,UAA1B,CAAqC,WAArC,CAAiD,UAAU,CAAC,gCAA5D,CAA6F,YAAY,QAAQ,CAAC,MAAM,EAA9N,CAAP;AACH;AACJ,OAfM,CAAP;AAgBH,KAjCoC,CAAzC;AAmCA,SAAK,kBAAL,GAA0B,KAAK,gBAAL,EAA1B;AACA,WAAO,KAAK,iCAAZ;AACH;;AA+UO,EAAA,gBAAgB,GAAA;AAEpB,SAAK,oBAAL,GAA4B,KAA5B;AAEA,UAAM,uBAAuB,GAAG,KAAK,kCAAL,EAAhC;AAEA,WAAO,uBAAuB,CAAC,EAAxB,CAA4B,CAAD,IAAmB;AACjD,aAAO,IAAP;AACH,KAFM,EAEH,KAAD,IAAkB;AACjB,WAAK,iBAAL,CACI,KAAK,kBAAL,GAA0B,KAAK,kBAAL,CAAwB,SAAlD,GAA8D,EADlE,EAEI,KAAK,kBAAL,GAA0B,KAAK,kBAAL,CAAwB,SAAlD,GAA8D,EAFlE,EAGI,kBAAkB,CAAC,KAHvB,EAII,qBAAqB,CAAC,YAJ1B,EAKI,KALJ;AAMH,KATM,CAAP;AAUH,GAnjBgE,CAqjBjE;;;AACQ,EAAA,gBAAgB,GAAA;AACpB,QAAI,KAAK,2BAAT,EAAsC;AAClC,UAAI,KAAK,2BAAL,CAAiC,MAAjC,GAA0C,WAA1C,KACC,KAAK,2BAAL,CAAiC,MAAjC,GAA0C,OAA1C,IACM,KAAK,2BAAL,CAAiC,MAAjC,GAA0C,MAA1C,CAAiD,KAAjD,OAA6D,eAAe,CAAC,YAFpF,CAAJ,EAEuG;AAEnG,aAAK,2BAAL,GAAmC,IAAnC;AACA,eAAO,KAAK,gBAAL,EAAP;AACH,OAND,MAMO;AACH,eAAO,KAAK,2BAAZ;AACH;AACJ;;AAED,QAAI,KAAK,oBAAT,EAA+B;AAC3B,aAAO,aAAa,CAAC,UAAd,CAAsC,SAAtC,CAAP;AACH;;AAED,SAAK,2BAAL,GAAmC,KAAK,uBAAL,GAC9B,qBAD8B,CACP,UAAD,IAAiC;AACpD,aAAO,UAAP;AACP,KAHkC,CAAnC;AAIA,WAAO,KAAK,2BAAZ;AACH;;AAEO,EAAA,eAAe,CAAC,yBAAD,EAAyD;AAC5E,QAAI,YAAJ;;AAEA,QAAI,SAAS,KAAK,yBAAlB,EAA6C;AACzC,MAAA,YAAY,GAAG,IAAI,YAAJ,EAAf;;AACA,WAAK,MAAM,WAAX,IAA0B,yBAA1B,EAAqD;AACjD,QAAA,YAAY,CAAC,GAAb,CAAiB,WAAW,CAAC,IAA7B,EAAmC,WAAW,CAAC,WAA/C;AACH;AACJ;;AAED,WAAO,YAAP;AACH;;AAzlBgE","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionOpenResponse,\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    IAudioSource,\r\n    IConnection,\r\n    MessageType,\r\n    Promise,\r\n    PromiseHelper,\r\n    PromiseResult\r\n} from \"../../common/Exports\";\r\nimport { Sink } from \"../../common/Promise\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    ConversationExpirationEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationResult,\r\n    PropertyId,\r\n    SessionEventArgs,\r\n    SpeechRecognitionResult,\r\n    Translations\r\n} from \"../../sdk/Exports\";\r\nimport {\r\n    AuthInfo, IAuthentication, IConnectionFactory, RecognizerConfig, ServiceRecognizerBase\r\n} from \"../Exports\";\r\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\r\nimport { ConversationRequestSession } from \"./ConversationRequestSession\";\r\nimport {\r\n    ConversationReceivedTranslationEventArgs,\r\n    LockRoomEventArgs,\r\n    MuteAllEventArgs,\r\n    ParticipantAttributeEventArgs,\r\n    ParticipantEventArgs,\r\n    ParticipantsListEventArgs } from \"./ConversationTranslatorEventArgs\";\r\nimport { ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes, IInternalParticipant } from \"./ConversationTranslatorInterfaces\";\r\nimport { ConversationTranslatorRecognizer } from \"./ConversationTranslatorRecognizer\";\r\nimport {\r\n    CommandResponsePayload,\r\n    IParticipantPayloadResponse,\r\n    IParticipantsListPayloadResponse,\r\n    ITranslationResponsePayload,\r\n    ParticipantPayloadResponse,\r\n    ParticipantsListPayloadResponse,\r\n    SpeechResponsePayload,\r\n    TextResponsePayload  } from \"./ServiceMessages/Exports\";\r\n\r\n/***\r\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\r\n */\r\nexport class ConversationServiceAdapter extends ServiceRecognizerBase {\r\n    private privConversationServiceConnector: ConversationTranslatorRecognizer;\r\n    private privConversationConnectionFactory: IConnectionFactory;\r\n    private privConversationAuthFetchEventId: string;\r\n    private privConversationAuthentication: IAuthentication;\r\n    private privConversationRequestSession: ConversationRequestSession;\r\n    private privConnectionConfigPromise: Promise<IConnection>;\r\n    private privConversationConnectionPromise: Promise<IConnection>;\r\n    private privConnectionLoop: Promise<IConnection>;\r\n    private terminateMessageLoop: boolean;\r\n    private privLastPartialUtteranceId: string = \"\";\r\n    private privConversationIsDisposed: boolean;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        conversationServiceConnector: ConversationTranslatorRecognizer) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\r\n\r\n        this.privConversationServiceConnector = conversationServiceConnector;\r\n        this.privConversationAuthentication = authentication;\r\n        this.receiveMessageOverride = this.receiveConversationMessageOverride;\r\n        this.recognizeOverride = this.noOp;\r\n        this.connectImplOverride = this.conversationConnectImpl;\r\n        this.configConnectionOverride = this.configConnection;\r\n        this.fetchConnectionOverride = this.fetchConversationConnection;\r\n        this.disconnectOverride = this.privDisconnect;\r\n        this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\r\n        this.privConversationConnectionFactory = connectionFactory;\r\n        this.privConversationIsDisposed = false;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privConversationIsDisposed;\r\n    }\r\n\r\n    public dispose(reason?: string): void {\r\n        this.privConversationIsDisposed = true;\r\n        if (this.privConnectionConfigPromise) {\r\n            this.privConnectionConfigPromise.onSuccessContinueWith((connection: IConnection) => {\r\n                connection.dispose(reason);\r\n            });\r\n        }\r\n    }\r\n\r\n    public sendMessage(message: string): void {\r\n        this.fetchConversationConnection().onSuccessContinueWith((connection: IConnection) => {\r\n        connection.send(new ConversationConnectionMessage(\r\n        MessageType.Text,\r\n        message));\r\n        });\r\n    }\r\n\r\n    public sendMessageAsync = (message: string): Promise<boolean> => {\r\n        const sink: Sink<boolean> = new Sink<boolean>();\r\n\r\n        this.fetchConversationConnection().continueWith((antecedent: PromiseResult<IConnection>): void => {\r\n            try {\r\n                if (antecedent.isError) {\r\n                    sink.reject(antecedent.error);\r\n                } else {\r\n                    antecedent.result.send(new ConversationConnectionMessage(MessageType.Text, message))\r\n                        .continueWith((innerAntecedent: PromiseResult<boolean>): void => {\r\n                            try {\r\n                                if (innerAntecedent.isError) {\r\n                                    sink.reject(innerAntecedent.error);\r\n                                } else {\r\n                                    sink.resolve(innerAntecedent.result);\r\n                                }\r\n                            } catch (e) {\r\n                                sink.reject(`Unhandled inner error: ${e}`);\r\n                            }\r\n                        });\r\n                }\r\n            } catch (e) {\r\n                sink.reject(`Unhandled error: ${e}`);\r\n            }\r\n        });\r\n\r\n        return new Promise<boolean>(sink);\r\n    }\r\n\r\n    protected privDisconnect(): void {\r\n        if (this.terminateMessageLoop) {\r\n            return;\r\n        }\r\n        this.cancelRecognition(this.privConversationRequestSession.sessionId,\r\n            this.privConversationRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        if (this.privConversationConnectionPromise.result().isCompleted) {\r\n            if (!this.privConversationConnectionPromise.result().isError) {\r\n                this.privConversationConnectionPromise.result().result.dispose();\r\n                this.privConversationConnectionPromise = null;\r\n            }\r\n        } else {\r\n            this.privConversationConnectionPromise.onSuccessContinueWith((connection: IConnection) => {\r\n                connection.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    protected processTypeSpecificMessages(\r\n        connectionMessage: ConnectionMessage,\r\n        successCallback?: (e: any) => void,\r\n        errorCallBack?: (e: string) => void): boolean {\r\n            return true;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n            this.terminateMessageLoop = true;\r\n\r\n            const cancelEvent: ConversationTranslationCanceledEventArgs = new ConversationTranslationCanceledEventArgs(\r\n                        cancellationReason,\r\n                        error,\r\n                        errorCode,\r\n                        undefined,\r\n                        sessionId);\r\n\r\n            try {\r\n                if (!!this.privConversationServiceConnector.canceled) {\r\n                    this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\r\n                }\r\n            } catch {\r\n                // continue on error\r\n            }\r\n    }\r\n\r\n    protected noOp = (): any => {\r\n        // operation not supported\r\n    }\r\n\r\n    /**\r\n     * Establishes a websocket connection to the end point.\r\n     * @param isUnAuthorized\r\n     */\r\n    protected conversationConnectImpl(isUnAuthorized: boolean = false): Promise<IConnection> {\r\n\r\n        if (this.privConversationConnectionPromise) {\r\n            if (this.privConversationConnectionPromise.result().isCompleted &&\r\n                (this.privConversationConnectionPromise.result().isError\r\n                    || this.privConversationConnectionPromise.result().result.state() === ConnectionState.Disconnected)) {\r\n                this.privConnectionId = null;\r\n                this.privConversationConnectionPromise = null;\r\n                this.terminateMessageLoop = true;\r\n                return this.conversationConnectImpl();\r\n            } else {\r\n                return this.privConversationConnectionPromise;\r\n            }\r\n        }\r\n\r\n        this.privConversationAuthFetchEventId = createNoDashGuid();\r\n\r\n        // keep the connectionId for reconnect events\r\n        if (this.privConnectionId === undefined) {\r\n            this.privConnectionId = createNoDashGuid();\r\n        }\r\n\r\n        this.privConversationRequestSession.onPreConnectionStart(this.privConversationAuthFetchEventId, this.privConnectionId);\r\n\r\n        const authPromise = isUnAuthorized ? this.privConversationAuthentication.fetchOnExpiry(this.privConversationAuthFetchEventId) : this.privConversationAuthentication.fetch(this.privConversationAuthFetchEventId);\r\n\r\n        this.privConversationConnectionPromise = authPromise\r\n            .continueWithPromise((result: PromiseResult<AuthInfo>) => {\r\n                if (result.isError) {\r\n                    this.privConversationRequestSession.onAuthCompleted(true, result.error);\r\n                    throw new Error(result.error);\r\n                } else {\r\n                    this.privConversationRequestSession.onAuthCompleted(false);\r\n                }\r\n\r\n                const connection: IConnection = this.privConversationConnectionFactory.create(this.privRecognizerConfig, result.result, this.privConnectionId);\r\n\r\n                // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\r\n                // it'll stop sending events.\r\n                connection.events.attach((event: ConnectionEvent) => {\r\n                    this.connectionEvents.onEvent(event);\r\n                });\r\n\r\n                return connection.open().onSuccessContinueWithPromise((response: ConnectionOpenResponse): Promise<IConnection> => {\r\n                    if (response.statusCode === 200) {\r\n                        this.privConversationRequestSession.onPreConnectionStart(this.privConversationAuthFetchEventId, this.privConnectionId);\r\n                        this.privConversationRequestSession.onConnectionEstablishCompleted(response.statusCode);\r\n                        const sessionStartEventArgs: SessionEventArgs = new SessionEventArgs(this.privConversationRequestSession.sessionId);\r\n                        if (!!this.privConversationServiceConnector.connectionOpened) {\r\n                            this.privConversationServiceConnector.connectionOpened(this.privConversationServiceConnector, sessionStartEventArgs);\r\n                        }\r\n                        return PromiseHelper.fromResult<IConnection>(connection);\r\n                    } else if (response.statusCode === 403 && !isUnAuthorized) {\r\n                        return this.conversationConnectImpl(true);\r\n                    } else {\r\n                        this.privConversationRequestSession.onConnectionEstablishCompleted(response.statusCode, response.reason);\r\n                        return PromiseHelper.fromError<IConnection>(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\r\n                    }\r\n                });\r\n            });\r\n\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return this.privConversationConnectionPromise;\r\n    }\r\n\r\n    /**\r\n     * Process incoming websocket messages\r\n     */\r\n    private receiveConversationMessageOverride = (\r\n        successCallback?: (e: any) => void,\r\n        errorCallBack?: (e: string) => void\r\n        ): Promise<IConnection> => {\r\n\r\n            // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n            const communicationCustodian: Deferred<IConnection> = new Deferred<IConnection>();\r\n\r\n            this.fetchConversationConnection().on((connection: IConnection): Promise<IConnection> => {\r\n                return connection.read()\r\n                    .onSuccessContinueWithPromise((message: ConversationConnectionMessage): Promise<IConnection> => {\r\n                        const isDisposed: boolean = this.isDisposed();\r\n                        const terminateMessageLoop = (!this.isDisposed() && this.terminateMessageLoop);\r\n                        const sessionId: string = this.privConversationRequestSession.sessionId;\r\n                        let sendFinal: boolean = false;\r\n                        if (isDisposed || terminateMessageLoop) {\r\n                            // We're done.\r\n                            communicationCustodian.resolve(undefined);\r\n                            return PromiseHelper.fromResult<IConnection>(undefined);\r\n                        }\r\n\r\n                        if (!message) {\r\n                            return this.receiveConversationMessageOverride();\r\n                        }\r\n\r\n                        try {\r\n                            switch (message.conversationMessageType.toLowerCase()) {\r\n                                case \"info\":\r\n                                case \"participant_command\":\r\n                                case \"command\":\r\n                                    const commandPayload: CommandResponsePayload = CommandResponsePayload.fromJSON(message.textBody);\r\n                                    switch (commandPayload.command.toLowerCase()) {\r\n\r\n                                        /**\r\n                                         * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\r\n                                         * The consuming client must wait for this message to arrive\r\n                                         * before starting to send their own data.\r\n                                         */\r\n                                        case \"participantlist\":\r\n\r\n                                            const participantsPayload: IParticipantsListPayloadResponse = ParticipantsListPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                            const participantsResult: IInternalParticipant[] = participantsPayload.participants.map((p: IParticipantPayloadResponse) => {\r\n                                                const participant: IInternalParticipant =  {\r\n                                                    avatar: p.avatar,\r\n                                                    displayName: p.nickname,\r\n                                                    id: p.participantId,\r\n                                                    isHost: p.ishost,\r\n                                                    isMuted: p.ismuted,\r\n                                                    isUsingTts: p.usetts,\r\n                                                    preferredLanguage: p.locale\r\n                                                };\r\n                                                return participant;\r\n                                            });\r\n\r\n                                            if (!!this.privConversationServiceConnector.participantsListReceived) {\r\n                                                this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector,\r\n                                                    new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token,\r\n                                                        participantsPayload.translateTo, participantsPayload.profanityFilter,\r\n                                                        participantsPayload.roomProfanityFilter, participantsPayload.roomLocked,\r\n                                                        participantsPayload.muteAll, participantsResult, sessionId));\r\n                                            }\r\n                                            break;\r\n\r\n                                        /**\r\n                                         * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\r\n                                         * This is sent at the start of the Conversation\r\n                                         */\r\n                                        case \"settranslatetolanguages\":\r\n\r\n                                            if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                                this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                                    new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                        ConversationTranslatorCommandTypes.setTranslateToLanguages,\r\n                                                        commandPayload.value, sessionId));\r\n                                            }\r\n\r\n                                            break;\r\n\r\n                                        /**\r\n                                         * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\r\n                                         * If sent by the participant the setting will effect only their own profanity level.\r\n                                         * If sent by the host, the setting will effect all participants including the host.\r\n                                         * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\r\n                                         */\r\n                                        case \"setprofanityfiltering\":\r\n\r\n                                            if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                                this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                                    new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                        ConversationTranslatorCommandTypes.setProfanityFiltering,\r\n                                                        commandPayload.value, sessionId));\r\n                                            }\r\n\r\n                                            break;\r\n\r\n                                        /**\r\n                                         * 'SetMute' is sent if the participant has been muted by the host.\r\n                                         * Check the 'participantId' to determine if the current user has been muted.\r\n                                         */\r\n                                        case \"setmute\":\r\n\r\n                                            if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                                this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                                    new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                        ConversationTranslatorCommandTypes.setMute,\r\n                                                        commandPayload.value, sessionId));\r\n                                            }\r\n\r\n                                            break;\r\n\r\n                                        /**\r\n                                         * 'SetMuteAll' is sent if the Conversation has been muted by the host.\r\n                                         */\r\n                                        case \"setmuteall\":\r\n\r\n                                            if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\r\n                                                this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector,\r\n                                                    new MuteAllEventArgs(commandPayload.value as boolean, sessionId));\r\n                                            }\r\n\r\n                                            break;\r\n\r\n                                        /**\r\n                                         * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\r\n                                         */\r\n                                        case \"roomexpirationwarning\":\r\n\r\n                                            if (!!this.privConversationServiceConnector.conversationExpiration) {\r\n                                                this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector,\r\n                                                    new ConversationExpirationEventArgs(commandPayload.value as number, this.privConversationRequestSession.sessionId));\r\n                                            }\r\n\r\n                                            break;\r\n\r\n                                        /**\r\n                                         * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\r\n                                         */\r\n                                        case \"setusetts\":\r\n\r\n                                            if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                                this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                                    new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                        ConversationTranslatorCommandTypes.setUseTTS,\r\n                                                        commandPayload.value, sessionId));\r\n                                            }\r\n\r\n                                            break;\r\n\r\n                                        /**\r\n                                         * 'SetLockState' is set if the host has locked or unlocked the Conversation.\r\n                                         */\r\n                                        case \"setlockstate\":\r\n\r\n                                            if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\r\n                                                this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector,\r\n                                                    new LockRoomEventArgs(commandPayload.value as boolean, sessionId));\r\n                                            }\r\n\r\n                                            break;\r\n\r\n                                        /**\r\n                                         * 'ChangeNickname' is received if a user changes their display name.\r\n                                         * Any cached particpiants list should be updated to reflect the display name.\r\n                                         */\r\n                                        case \"changenickname\":\r\n\r\n                                            if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                                this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                                    new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                        ConversationTranslatorCommandTypes.changeNickname,\r\n                                                        commandPayload.nickname, sessionId));\r\n                                            }\r\n\r\n                                            break;\r\n\r\n                                        /**\r\n                                         * 'JoinSession' is sent when a user joins the Conversation.\r\n                                         */\r\n                                        case \"joinsession\":\r\n\r\n                                            const joinParticipantPayload: ParticipantPayloadResponse = ParticipantPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                            const joiningParticipant: IInternalParticipant = {\r\n                                                avatar: joinParticipantPayload.avatar,\r\n                                                displayName: joinParticipantPayload.nickname,\r\n                                                id: joinParticipantPayload.participantId,\r\n                                                isHost: joinParticipantPayload.ishost,\r\n                                                isMuted: joinParticipantPayload.ismuted,\r\n                                                isUsingTts: joinParticipantPayload.usetts,\r\n                                                preferredLanguage: joinParticipantPayload.locale,\r\n                                            };\r\n\r\n                                            if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\r\n                                                this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector,\r\n                                                    new ParticipantEventArgs(\r\n                                                        joiningParticipant,\r\n                                                        sessionId));\r\n                                            }\r\n\r\n                                            break;\r\n\r\n                                        /**\r\n                                         * 'LeaveSession' is sent when a user leaves the Conversation'.\r\n                                         */\r\n                                        case \"leavesession\":\r\n\r\n                                            const leavingParticipant: IInternalParticipant = {\r\n                                                id: commandPayload.participantId\r\n                                            };\r\n\r\n                                            if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\r\n                                                this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector,\r\n                                                    new ParticipantEventArgs(leavingParticipant, sessionId));\r\n                                            }\r\n\r\n                                            break;\r\n\r\n                                        /**\r\n                                         * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\r\n                                         * Check the 'ParticipantId' to check whether the message is for the current user.\r\n                                         */\r\n                                        case \"disconnectsession\":\r\n\r\n                                            const disconnectParticipant: IInternalParticipant = {\r\n                                                id: commandPayload.participantId\r\n                                            };\r\n\r\n                                            break;\r\n\r\n                                        /**\r\n                                         * Message not recognized.\r\n                                         */\r\n                                        default:\r\n                                            break;\r\n                                    }\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'partial' (or 'hypothesis') represents a unfinalized speech message.\r\n                                 */\r\n                                case \"partial\":\r\n\r\n                                /**\r\n                                 * 'final' (or 'phrase') represents a finalized speech message.\r\n                                 */\r\n                                case \"final\":\r\n\r\n                                    const speechPayload: SpeechResponsePayload = SpeechResponsePayload.fromJSON(message.textBody);\r\n\r\n                                    const speechResult: ConversationTranslationResult = new ConversationTranslationResult(speechPayload.participantId,\r\n                                        this.getTranslations(speechPayload.translations),\r\n                                        speechPayload.language,\r\n                                        undefined,\r\n                                        undefined,\r\n                                        speechPayload.recognition,\r\n                                        undefined,\r\n                                        undefined,\r\n                                        message.textBody,\r\n                                        undefined);\r\n\r\n                                    if (speechPayload.isFinal) {\r\n                                        // check the length, sometimes empty finals are returned\r\n                                        if (speechResult.text !== undefined && speechResult.text.length > 0) {\r\n                                            sendFinal = true;\r\n                                        } else if (speechPayload.id === this.privLastPartialUtteranceId) {\r\n                                            // send final as normal. We had a non-empty partial for this same utterance\r\n                                            // so sending the empty final is important\r\n                                            sendFinal = true;\r\n                                        } else {\r\n                                            // suppress unneeded final\r\n                                        }\r\n\r\n                                        if (sendFinal) {\r\n                                            if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                                    new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\r\n                                            }\r\n                                        }\r\n                                    }  else if (speechResult.text !== undefined) {\r\n                                        this.privLastPartialUtteranceId = speechPayload.id;\r\n                                        if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                            this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                                new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\r\n                                        }\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * \"translated_message\" is a text message or instant message (IM).\r\n                                 */\r\n                                case \"translated_message\":\r\n\r\n                                    const textPayload: TextResponsePayload = TextResponsePayload.fromJSON(message.textBody);\r\n\r\n                                    const textResult: ConversationTranslationResult = new ConversationTranslationResult(textPayload.participantId,\r\n                                                this.getTranslations(textPayload.translations),\r\n                                                textPayload.language,\r\n                                                undefined,\r\n                                                undefined,\r\n                                                textPayload.originalText,\r\n                                                undefined,\r\n                                                undefined,\r\n                                                undefined,\r\n                                                message.textBody,\r\n                                                undefined);\r\n\r\n                                    if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                        this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                            new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\r\n                                    }\r\n                                    break;\r\n\r\n                                default:\r\n                                    // ignore any unsupported message types\r\n                                    break;\r\n                            }\r\n                        } catch (e) {\r\n                            // continue\r\n                        }\r\n                        return this.receiveConversationMessageOverride();\r\n                });\r\n            }, (error: string) => {\r\n                this.terminateMessageLoop = true;\r\n            });\r\n\r\n            return communicationCustodian.promise();\r\n        }\r\n\r\n    private startMessageLoop(): Promise<IConnection> {\r\n\r\n        this.terminateMessageLoop = false;\r\n\r\n        const messageRetrievalPromise = this.receiveConversationMessageOverride();\r\n\r\n        return messageRetrievalPromise.on((r: IConnection) => {\r\n            return true;\r\n        }, (error: string) => {\r\n            this.cancelRecognition(\r\n                this.privRequestSession ? this.privRequestSession.sessionId : \"\",\r\n                this.privRequestSession ? this.privRequestSession.requestId : \"\",\r\n                CancellationReason.Error,\r\n                CancellationErrorCode.RuntimeError,\r\n                error);\r\n        });\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint\r\n    private configConnection(): Promise<IConnection> {\r\n        if (this.privConnectionConfigPromise) {\r\n            if (this.privConnectionConfigPromise.result().isCompleted &&\r\n                (this.privConnectionConfigPromise.result().isError\r\n                    || this.privConnectionConfigPromise.result().result.state() === ConnectionState.Disconnected)) {\r\n\r\n                this.privConnectionConfigPromise = null;\r\n                return this.configConnection();\r\n            } else {\r\n                return this.privConnectionConfigPromise;\r\n            }\r\n        }\r\n\r\n        if (this.terminateMessageLoop) {\r\n            return PromiseHelper.fromResult<IConnection>(undefined);\r\n        }\r\n\r\n        this.privConnectionConfigPromise = this.conversationConnectImpl()\r\n            .onSuccessContinueWith((connection: IConnection): any => {\r\n                return connection;\r\n        });\r\n        return this.privConnectionConfigPromise;\r\n    }\r\n\r\n    private getTranslations(serviceResultTranslations: ITranslationResponsePayload[]): Translations {\r\n        let translations: Translations;\r\n\r\n        if (undefined !== serviceResultTranslations) {\r\n            translations = new Translations();\r\n            for (const translation of serviceResultTranslations) {\r\n                translations.set(translation.lang, translation.translation);\r\n            }\r\n        }\r\n\r\n        return translations;\r\n    }\r\n\r\n    private fetchConversationConnection = (): Promise<IConnection> => {\r\n        return this.configConnection();\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}