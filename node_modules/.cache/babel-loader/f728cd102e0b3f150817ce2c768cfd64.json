{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { createNoDashGuid } from \"../../common/Exports\";\nimport { AudioFormatTag } from \"./AudioOutputFormat\";\nconst MediaDurationPlaceholderSeconds = 60 * 30;\nconst AudioFormatToMimeType = {\n  [AudioFormatTag.PCM]: \"audio/wav\",\n  [AudioFormatTag.MP3]: \"audio/mpeg\"\n};\n/**\n * Represents the speaker playback audio destination, which only works in browser.\n * Note: the playback is based on <a href=\"https://www.w3.org/TR/media-source/\">Media Source Extensions</a>, on most browsers, only mp3 format is supported.\n * @class SpeakerAudioDestination\n * Updated in version 1.12.0\n */\n\nexport class SpeakerAudioDestination {\n  constructor(audioDestinationId) {\n    this.privPlaybackStarted = false;\n    this.privAppendingToBuffer = false;\n    this.privMediaSourceOpened = false;\n    this.privId = audioDestinationId ? audioDestinationId : createNoDashGuid();\n    this.privIsPaused = false;\n    this.privIsClosed = false;\n  }\n\n  id() {\n    return this.privId;\n  }\n\n  write(buffer) {\n    if (this.privAudioBuffer !== undefined) {\n      this.privAudioBuffer.push(buffer);\n      this.updateSourceBuffer();\n    }\n  }\n\n  close() {\n    this.privIsClosed = true;\n\n    if (this.privSourceBuffer !== undefined) {\n      this.handleSourceBufferUpdateEnd();\n    }\n  }\n\n  set format(format) {\n    if (typeof AudioContext !== \"undefined\") {\n      this.privFormat = format;\n      const mimeType = AudioFormatToMimeType[this.privFormat.formatTag];\n\n      if (mimeType !== undefined && typeof MediaSource !== \"undefined\" && MediaSource.isTypeSupported(mimeType)) {\n        this.privAudio = new Audio();\n        this.privAudioBuffer = [];\n        this.privMediaSource = new MediaSource();\n        this.privAudio.src = URL.createObjectURL(this.privMediaSource);\n        this.privAudio.load();\n\n        this.privMediaSource.onsourceopen = event => {\n          this.privMediaSourceOpened = true;\n          this.privMediaSource.duration = MediaDurationPlaceholderSeconds;\n          this.privSourceBuffer = this.privMediaSource.addSourceBuffer(\"audio/mpeg\");\n\n          this.privSourceBuffer.onupdate = _ => {\n            this.updateSourceBuffer();\n          };\n\n          this.privSourceBuffer.onupdateend = _ => {\n            this.handleSourceBufferUpdateEnd();\n          };\n\n          this.privSourceBuffer.onupdatestart = _ => {\n            this.privAppendingToBuffer = false;\n          };\n        };\n\n        this.updateSourceBuffer();\n      } else {\n        // tslint:disable-next-line:no-console\n        console.warn(`Format ${AudioFormatTag[this.privFormat.formatTag]} is not supported for playback.`);\n      }\n    }\n  }\n\n  get isClosed() {\n    return this.privIsClosed;\n  }\n\n  get currentTime() {\n    if (this.privAudio !== undefined) {\n      return this.privAudio.currentTime;\n    }\n\n    return -1;\n  }\n\n  pause() {\n    if (!this.privIsPaused && this.privAudio !== undefined) {\n      this.privAudio.pause();\n      this.privIsPaused = true;\n    }\n  }\n\n  resume() {\n    if (this.privIsPaused && this.privAudio !== undefined) {\n      this.privAudio.play();\n      this.privIsPaused = false;\n    }\n  }\n\n  get internalAudio() {\n    return this.privAudio;\n  }\n\n  updateSourceBuffer() {\n    if (this.privAudioBuffer !== undefined && this.privAudioBuffer.length > 0 && this.sourceBufferAvailable()) {\n      this.privAppendingToBuffer = true;\n      const binary = this.privAudioBuffer.shift();\n\n      try {\n        this.privSourceBuffer.appendBuffer(binary);\n      } catch (error) {\n        this.privAudioBuffer.unshift(binary); // tslint:disable-next-line:no-console\n\n        console.log(\"buffer filled, pausing addition of binaries until space is made\");\n        return;\n      }\n\n      this.notifyPlayback();\n    } else if (this.canEndStream()) {\n      this.handleSourceBufferUpdateEnd();\n    }\n  }\n\n  handleSourceBufferUpdateEnd() {\n    if (this.canEndStream() && this.sourceBufferAvailable()) {\n      this.privMediaSource.endOfStream();\n      this.notifyPlayback();\n    }\n  }\n\n  notifyPlayback() {\n    if (!this.privPlaybackStarted && this.privAudio !== undefined) {\n      this.privAudio.onended = () => {\n        if (!!this.onAudioEnd) {\n          this.onAudioEnd(this);\n        }\n      };\n\n      if (!this.privIsPaused) {\n        this.privAudio.play();\n      }\n\n      this.privPlaybackStarted = true;\n    }\n  }\n\n  canEndStream() {\n    return this.isClosed && this.privSourceBuffer !== undefined && this.privAudioBuffer.length === 0 && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === \"open\";\n  }\n\n  sourceBufferAvailable() {\n    return this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating;\n  }\n\n}","map":{"version":3,"sources":["src/sdk/Audio/SpeakerAudioDestination.ts"],"names":[],"mappings":"AAAA;AACA;AAEA,SACI,gBADJ,QAIO,sBAJP;AAMA,SAAS,cAAT,QAAsD,qBAAtD;AAEA,MAAM,+BAA+B,GAAG,KAAK,EAA7C;AAEA,MAAM,qBAAqB,GAA8B;AACrD,GAAC,cAAc,CAAC,GAAhB,GAAsB,WAD+B;AAErD,GAAC,cAAc,CAAC,GAAhB,GAAsB;AAF+B,CAAzD;AAKA;;;;;;;AAMA,OAAM,MAAO,uBAAP,CAA8B;AAahC,EAAA,WAAA,CAAmB,kBAAnB,EAA8C;AAPtC,SAAA,mBAAA,GAA+B,KAA/B;AAEA,SAAA,qBAAA,GAAiC,KAAjC;AACA,SAAA,qBAAA,GAAiC,KAAjC;AAKJ,SAAK,MAAL,GAAc,kBAAkB,GAAG,kBAAH,GAAwB,gBAAgB,EAAxE;AACA,SAAK,YAAL,GAAoB,KAApB;AACA,SAAK,YAAL,GAAoB,KAApB;AACH;;AAEM,EAAA,EAAE,GAAA;AACL,WAAO,KAAK,MAAZ;AACH;;AAEM,EAAA,KAAK,CAAC,MAAD,EAAoB;AAC5B,QAAI,KAAK,eAAL,KAAyB,SAA7B,EAAwC;AACpC,WAAK,eAAL,CAAqB,IAArB,CAA0B,MAA1B;AACA,WAAK,kBAAL;AACH;AACJ;;AAEM,EAAA,KAAK,GAAA;AACR,SAAK,YAAL,GAAoB,IAApB;;AACA,QAAI,KAAK,gBAAL,KAA0B,SAA9B,EAAyC;AACrC,WAAK,2BAAL;AACH;AACJ;;AAED,MAAI,MAAJ,CAAW,MAAX,EAAoC;AAChC,QAAI,OAAQ,YAAR,KAA0B,WAA9B,EAA2C;AACvC,WAAK,UAAL,GAAkB,MAAlB;AACA,YAAM,QAAQ,GAAW,qBAAqB,CAAC,KAAK,UAAL,CAAgB,SAAjB,CAA9C;;AACA,UAAI,QAAQ,KAAK,SAAb,IAA0B,OAAO,WAAP,KAAwB,WAAlD,IAAiE,WAAW,CAAC,eAAZ,CAA4B,QAA5B,CAArE,EAA4G;AACxG,aAAK,SAAL,GAAiB,IAAI,KAAJ,EAAjB;AACA,aAAK,eAAL,GAAuB,EAAvB;AACA,aAAK,eAAL,GAAuB,IAAI,WAAJ,EAAvB;AACA,aAAK,SAAL,CAAe,GAAf,GAAqB,GAAG,CAAC,eAAJ,CAAoB,KAAK,eAAzB,CAArB;AACA,aAAK,SAAL,CAAe,IAAf;;AACA,aAAK,eAAL,CAAqB,YAArB,GAAqC,KAAD,IAAuB;AACvD,eAAK,qBAAL,GAA6B,IAA7B;AACA,eAAK,eAAL,CAAqB,QAArB,GAAgC,+BAAhC;AACA,eAAK,gBAAL,GAAwB,KAAK,eAAL,CAAqB,eAArB,CAAqC,YAArC,CAAxB;;AACA,eAAK,gBAAL,CAAsB,QAAtB,GAAkC,CAAD,IAAa;AAC1C,iBAAK,kBAAL;AACH,WAFD;;AAGA,eAAK,gBAAL,CAAsB,WAAtB,GAAqC,CAAD,IAAa;AAC7C,iBAAK,2BAAL;AACH,WAFD;;AAGA,eAAK,gBAAL,CAAsB,aAAtB,GAAuC,CAAD,IAAa;AAC/C,iBAAK,qBAAL,GAA6B,KAA7B;AACH,WAFD;AAGH,SAbD;;AAcA,aAAK,kBAAL;AACH,OArBD,MAqBO;AACH;AACA,QAAA,OAAO,CAAC,IAAR,CACI,UAAU,cAAc,CAAC,KAAK,UAAL,CAAgB,SAAjB,CAA2B,iCADvD;AAEH;AACJ;AACJ;;AAED,MAAW,QAAX,GAAmB;AACf,WAAO,KAAK,YAAZ;AACH;;AAED,MAAW,WAAX,GAAsB;AAClB,QAAI,KAAK,SAAL,KAAmB,SAAvB,EAAkC;AAC9B,aAAO,KAAK,SAAL,CAAe,WAAtB;AACH;;AACD,WAAO,CAAC,CAAR;AACH;;AAEM,EAAA,KAAK,GAAA;AACR,QAAI,CAAC,KAAK,YAAN,IAAsB,KAAK,SAAL,KAAmB,SAA7C,EAAwD;AACpD,WAAK,SAAL,CAAe,KAAf;AACA,WAAK,YAAL,GAAoB,IAApB;AACH;AACJ;;AAEM,EAAA,MAAM,GAAA;AACT,QAAI,KAAK,YAAL,IAAqB,KAAK,SAAL,KAAmB,SAA5C,EAAuD;AACnD,WAAK,SAAL,CAAe,IAAf;AACA,WAAK,YAAL,GAAoB,KAApB;AACH;AACJ;;AAID,MAAW,aAAX,GAAwB;AACpB,WAAO,KAAK,SAAZ;AACH;;AAEO,EAAA,kBAAkB,GAAA;AACtB,QAAI,KAAK,eAAL,KAAyB,SAAzB,IAAuC,KAAK,eAAL,CAAqB,MAArB,GAA8B,CAArE,IAA2E,KAAK,qBAAL,EAA/E,EAA6G;AACzG,WAAK,qBAAL,GAA6B,IAA7B;AACA,YAAM,MAAM,GAAG,KAAK,eAAL,CAAqB,KAArB,EAAf;;AACA,UAAI;AACA,aAAK,gBAAL,CAAsB,YAAtB,CAAmC,MAAnC;AACH,OAFD,CAEE,OAAO,KAAP,EAAc;AACZ,aAAK,eAAL,CAAqB,OAArB,CAA6B,MAA7B,EADY,CAEZ;;AACA,QAAA,OAAO,CAAC,GAAR,CACI,iEADJ;AAEA;AACH;;AACD,WAAK,cAAL;AACH,KAbD,MAaO,IAAI,KAAK,YAAL,EAAJ,EAAyB;AAC5B,WAAK,2BAAL;AACH;AACJ;;AAEO,EAAA,2BAA2B,GAAA;AAC/B,QAAI,KAAK,YAAL,MAAuB,KAAK,qBAAL,EAA3B,EAAyD;AACrD,WAAK,eAAL,CAAqB,WAArB;AACA,WAAK,cAAL;AACH;AACJ;;AAEO,EAAA,cAAc,GAAA;AAClB,QAAI,CAAC,KAAK,mBAAN,IAA6B,KAAK,SAAL,KAAmB,SAApD,EAA+D;AAC3D,WAAK,SAAL,CAAe,OAAf,GAAyB,MAAW;AAChC,YAAI,CAAC,CAAC,KAAK,UAAX,EAAuB;AACnB,eAAK,UAAL,CAAgB,IAAhB;AACH;AACJ,OAJD;;AAKA,UAAI,CAAC,KAAK,YAAV,EAAwB;AACpB,aAAK,SAAL,CAAe,IAAf;AACH;;AACD,WAAK,mBAAL,GAA2B,IAA3B;AACH;AACJ;;AAEO,EAAA,YAAY,GAAA;AAChB,WAAQ,KAAK,QAAL,IAAiB,KAAK,gBAAL,KAA0B,SAA3C,IAAyD,KAAK,eAAL,CAAqB,MAArB,KAAgC,CAAzF,IACD,KAAK,qBADJ,IAC6B,CAAC,KAAK,qBADnC,IAC4D,KAAK,eAAL,CAAqB,UAArB,KAAoC,MADxG;AAEH;;AAEO,EAAA,qBAAqB,GAAA;AACzB,WAAQ,KAAK,gBAAL,KAA0B,SAA1B,IAAuC,CAAC,KAAK,gBAAL,CAAsB,QAAtE;AACH;;AApJ+B","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    createNoDashGuid,\r\n    IAudioDestination,\r\n    INumberDictionary\r\n} from \"../../common/Exports\";\r\nimport { AudioStreamFormat, IPlayer } from \"../Exports\";\r\nimport { AudioFormatTag, AudioOutputFormatImpl } from \"./AudioOutputFormat\";\r\n\r\nconst MediaDurationPlaceholderSeconds = 60 * 30;\r\n\r\nconst AudioFormatToMimeType: INumberDictionary<string> = {\r\n    [AudioFormatTag.PCM]: \"audio/wav\",\r\n    [AudioFormatTag.MP3]: \"audio/mpeg\",\r\n};\r\n\r\n/**\r\n * Represents the speaker playback audio destination, which only works in browser.\r\n * Note: the playback is based on <a href=\"https://www.w3.org/TR/media-source/\">Media Source Extensions</a>, on most browsers, only mp3 format is supported.\r\n * @class SpeakerAudioDestination\r\n * Updated in version 1.12.0\r\n */\r\nexport class SpeakerAudioDestination implements IAudioDestination, IPlayer {\r\n    private readonly privId: string;\r\n    private privFormat: AudioOutputFormatImpl;\r\n    private privAudio: HTMLAudioElement;\r\n    private privMediaSource: MediaSource;\r\n    private privSourceBuffer: SourceBuffer;\r\n    private privPlaybackStarted: boolean = false;\r\n    private privAudioBuffer: ArrayBuffer[];\r\n    private privAppendingToBuffer: boolean = false;\r\n    private privMediaSourceOpened: boolean = false;\r\n    private privIsClosed: boolean;\r\n    private privIsPaused: boolean;\r\n\r\n    public constructor(audioDestinationId?: string) {\r\n        this.privId = audioDestinationId ? audioDestinationId : createNoDashGuid();\r\n        this.privIsPaused = false;\r\n        this.privIsClosed = false;\r\n    }\r\n\r\n    public id(): string {\r\n        return this.privId;\r\n    }\r\n\r\n    public write(buffer: ArrayBuffer): void {\r\n        if (this.privAudioBuffer !== undefined) {\r\n            this.privAudioBuffer.push(buffer);\r\n            this.updateSourceBuffer();\r\n        }\r\n    }\r\n\r\n    public close(): void {\r\n        this.privIsClosed = true;\r\n        if (this.privSourceBuffer !== undefined) {\r\n            this.handleSourceBufferUpdateEnd();\r\n        }\r\n    }\r\n\r\n    set format(format: AudioStreamFormat) {\r\n        if (typeof (AudioContext) !== \"undefined\") {\r\n            this.privFormat = format as AudioOutputFormatImpl;\r\n            const mimeType: string = AudioFormatToMimeType[this.privFormat.formatTag];\r\n            if (mimeType !== undefined && typeof(MediaSource) !== \"undefined\" && MediaSource.isTypeSupported(mimeType)) {\r\n                this.privAudio = new Audio();\r\n                this.privAudioBuffer = [];\r\n                this.privMediaSource = new MediaSource();\r\n                this.privAudio.src = URL.createObjectURL(this.privMediaSource);\r\n                this.privAudio.load();\r\n                this.privMediaSource.onsourceopen = (event: Event): void => {\r\n                    this.privMediaSourceOpened = true;\r\n                    this.privMediaSource.duration = MediaDurationPlaceholderSeconds;\r\n                    this.privSourceBuffer = this.privMediaSource.addSourceBuffer(\"audio/mpeg\");\r\n                    this.privSourceBuffer.onupdate = (_: Event) => {\r\n                        this.updateSourceBuffer();\r\n                    };\r\n                    this.privSourceBuffer.onupdateend = (_: Event) => {\r\n                        this.handleSourceBufferUpdateEnd();\r\n                    };\r\n                    this.privSourceBuffer.onupdatestart = (_: Event) => {\r\n                        this.privAppendingToBuffer = false;\r\n                    };\r\n                };\r\n                this.updateSourceBuffer();\r\n            } else {\r\n                // tslint:disable-next-line:no-console\r\n                console.warn(\r\n                    `Format ${AudioFormatTag[this.privFormat.formatTag]} is not supported for playback.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    public get isClosed(): boolean {\r\n        return this.privIsClosed;\r\n    }\r\n\r\n    public get currentTime(): number {\r\n        if (this.privAudio !== undefined) {\r\n            return this.privAudio.currentTime;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public pause(): void {\r\n        if (!this.privIsPaused && this.privAudio !== undefined) {\r\n            this.privAudio.pause();\r\n            this.privIsPaused = true;\r\n        }\r\n    }\r\n\r\n    public resume(): void {\r\n        if (this.privIsPaused && this.privAudio !== undefined) {\r\n            this.privAudio.play();\r\n            this.privIsPaused = false;\r\n        }\r\n    }\r\n\r\n    public onAudioEnd: (sender: IPlayer) => void;\r\n\r\n    public get internalAudio(): HTMLAudioElement {\r\n        return this.privAudio;\r\n    }\r\n\r\n    private updateSourceBuffer(): void {\r\n        if (this.privAudioBuffer !== undefined && (this.privAudioBuffer.length > 0) && this.sourceBufferAvailable()) {\r\n            this.privAppendingToBuffer = true;\r\n            const binary = this.privAudioBuffer.shift();\r\n            try {\r\n                this.privSourceBuffer.appendBuffer(binary);\r\n            } catch (error) {\r\n                this.privAudioBuffer.unshift(binary);\r\n                // tslint:disable-next-line:no-console\r\n                console.log(\r\n                    \"buffer filled, pausing addition of binaries until space is made\");\r\n                return;\r\n            }\r\n            this.notifyPlayback();\r\n        } else if (this.canEndStream()) {\r\n            this.handleSourceBufferUpdateEnd();\r\n        }\r\n    }\r\n\r\n    private handleSourceBufferUpdateEnd(): void {\r\n        if (this.canEndStream() && this.sourceBufferAvailable()) {\r\n            this.privMediaSource.endOfStream();\r\n            this.notifyPlayback();\r\n        }\r\n    }\r\n\r\n    private notifyPlayback(): void {\r\n        if (!this.privPlaybackStarted && this.privAudio !== undefined) {\r\n            this.privAudio.onended = (): void => {\r\n                if (!!this.onAudioEnd) {\r\n                    this.onAudioEnd(this);\r\n                }\r\n            };\r\n            if (!this.privIsPaused) {\r\n                this.privAudio.play();\r\n            }\r\n            this.privPlaybackStarted = true;\r\n        }\r\n    }\r\n\r\n    private canEndStream(): boolean {\r\n        return (this.isClosed && this.privSourceBuffer !== undefined && (this.privAudioBuffer.length === 0)\r\n            && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === \"open\");\r\n    }\r\n\r\n    private sourceBufferAvailable(): boolean {\r\n        return (this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}