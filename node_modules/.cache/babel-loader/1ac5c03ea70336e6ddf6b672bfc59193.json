{"ast":null,"code":"var _jsxFileName = \"/Users/nikhilr5/Desktop/ScribeAR/updatedStore/src/components/Captions/Recognition/index.js\";\nimport React from 'react';\nconst SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\nconst recognition = new SpeechRecognition();\nrecognition.lang = 'en-US';\nrecognition.continuous = false;\nrecognition.interimResults = true; // In this document, a 'line' is more like a sentence.\n// this.state.line is like a buffer of text held at the end of the page. When the line\n// is finished, the buffer is flushed: a new div is appended to the 'out' div and\n// this.state.line is reset for the next line.\n\nclass Recognition extends React.PureComponent {\n  constructor() {\n    super();\n    this.state = {\n      line: '' //recording: true\n\n    };\n    this.appendLine = this.appendLine.bind(this);\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n  }\n\n  componentDidMount() {\n    this.start();\n  } // Global state 'recording' is passed as a prop. componentDidUpdate is invoked\n  // when props change, therefore also when 'recording' changes.\n\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevProps.isRecording === this.props.isRecording) return;\n    if (this.props.isRecording) this.start();else this.stop();\n  }\n\n  start() {\n    recognition.start(); // Map the complex recognition result object to a string. You can explore\n    // the full object with console.log(e).\n\n    recognition.onresult = e => {\n      let words = Array.from(e.results).map(result => result[0]).map(result => result.transcript).join('');\n      words = words.charAt(0).toUpperCase() + words.slice(1);\n      if (e.results[0].isFinal) // if line is final\n        this.appendLine(words + '.'); // flush buffer\n      else this.updateCurrentLine(words); // update state\n    }; // By default, recognition stops when it gets a final result.\n\n\n    recognition.onend = recognition.start; // override this behavior\n  }\n\n  stop() {\n    recognition.onresult = () => {}; // do nothing with results\n\n\n    recognition.onend = () => {}; // don't restart when ending\n\n\n    recognition.stop();\n  }\n\n  updateCurrentLine(str) {\n    const capts = document.getElementById('captionsSpace');\n    var isScrolledToBottom = capts.scrollHeight - capts.clientHeight <= capts.scrollTop + 1;\n    this.setState({\n      line: str\n    });\n    if (isScrolledToBottom) capts.scrollTop = capts.scrollHeight - capts.clientHeight;\n  }\n\n  appendLine(str) {\n    const capts = document.getElementById('captionsSpace');\n    const out = document.getElementById('out');\n    var isScrolledToBottom = capts.scrollHeight - capts.clientHeight <= capts.scrollTop + 1;\n    var div = document.createElement('div'); // create new div\n\n    div.textContent = str; // set new div's text to the updated current line\n\n    out.appendChild(div); // add the new div to the document inside 'out' element\n\n    this.setState({\n      line: ''\n    }); // reset line\n\n    if (isScrolledToBottom) capts.scrollTop = capts.scrollHeight - capts.clientHeight; // scroll to bottom\n  }\n\n  render() {\n    // out holds all past lines. curr holds the current line.\n    return /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 87,\n        columnNumber: 16\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      id: \"out\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 88,\n        columnNumber: 21\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      id: \"curr\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 89,\n        columnNumber: 21\n      }\n    }, this.state.line));\n  }\n\n}\n\nexport default Recognition;","map":{"version":3,"sources":["/Users/nikhilr5/Desktop/ScribeAR/updatedStore/src/components/Captions/Recognition/index.js"],"names":["React","SpeechRecognition","window","webkitSpeechRecognition","recognition","lang","continuous","interimResults","Recognition","PureComponent","constructor","state","line","appendLine","bind","start","stop","componentDidMount","componentDidUpdate","prevProps","prevState","isRecording","props","onresult","e","words","Array","from","results","map","result","transcript","join","charAt","toUpperCase","slice","isFinal","updateCurrentLine","onend","str","capts","document","getElementById","isScrolledToBottom","scrollHeight","clientHeight","scrollTop","setState","out","div","createElement","textContent","appendChild","render"],"mappings":"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","sourcesContent":["import React from 'react'\r\n\r\nconst SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition\r\nconst recognition = new SpeechRecognition()\r\nrecognition.lang = 'en-US'\r\nrecognition.continuous = false\r\nrecognition.interimResults = true\r\n\r\n// In this document, a 'line' is more like a sentence.\r\n// this.state.line is like a buffer of text held at the end of the page. When the line\r\n// is finished, the buffer is flushed: a new div is appended to the 'out' div and\r\n// this.state.line is reset for the next line.\r\n\r\nclass Recognition extends React.PureComponent {\r\n     constructor() {\r\n          super()\r\n          this.state = {\r\n               line: '',\r\n               //recording: true\r\n          }\r\n          this.appendLine = this.appendLine.bind(this)\r\n          this.start = this.start.bind(this)\r\n          this.stop = this.stop.bind(this)\r\n     }\r\n\r\n     componentDidMount() {\r\n          this.start()\r\n     }\r\n\r\n     // Global state 'recording' is passed as a prop. componentDidUpdate is invoked\r\n     // when props change, therefore also when 'recording' changes.\r\n     componentDidUpdate(prevProps, prevState) {\r\n          if (prevProps.isRecording === this.props.isRecording)\r\n               return\r\n          if (this.props.isRecording)\r\n               this.start()\r\n          else this.stop()\r\n     }\r\n\r\n     start() {\r\n          recognition.start()\r\n          // Map the complex recognition result object to a string. You can explore\r\n          // the full object with console.log(e).\r\n          recognition.onresult = (e) => {\r\n               let words = Array.from(e.results)\r\n                 .map(result => result[0])\r\n                 .map(result => result.transcript)\r\n                 .join('');\r\n               words = words.charAt(0).toUpperCase() + words.slice(1)\r\n               if (e.results[0].isFinal) // if line is final\r\n                    this.appendLine(words + '.') // flush buffer\r\n               else this.updateCurrentLine(words) // update state\r\n          }\r\n          // By default, recognition stops when it gets a final result.\r\n          recognition.onend = recognition.start // override this behavior\r\n     }\r\n\r\n     stop() {\r\n          recognition.onresult = () => {} // do nothing with results\r\n          recognition.onend = () => {} // don't restart when ending\r\n          recognition.stop()\r\n     }\r\n\r\n     updateCurrentLine(str) {\r\n          const capts = document.getElementById('captionsSpace')\r\n          var isScrolledToBottom = capts.scrollHeight - capts.clientHeight <= capts.scrollTop + 1\r\n          this.setState({ line: str })\r\n          if (isScrolledToBottom)\r\n               capts.scrollTop = capts.scrollHeight - capts.clientHeight\r\n     }\r\n\r\n     appendLine(str) {\r\n          const capts = document.getElementById('captionsSpace')\r\n          const out = document.getElementById('out')\r\n          var isScrolledToBottom = capts.scrollHeight - capts.clientHeight <= capts.scrollTop + 1\r\n          var div = document.createElement('div') // create new div\r\n          div.textContent = str // set new div's text to the updated current line\r\n          out.appendChild(div) // add the new div to the document inside 'out' element\r\n          this.setState({ line: '' }) // reset line\r\n          if (isScrolledToBottom)\r\n               capts.scrollTop = capts.scrollHeight - capts.clientHeight // scroll to bottom\r\n     }\r\n\r\n     render() {\r\n          // out holds all past lines. curr holds the current line.\r\n          return (\r\n               <div>\r\n                    <div id='out'></div>\r\n                    <div id='curr'>{this.state.line}</div>\r\n               </div>\r\n          )\r\n     }\r\n}\r\n\r\nexport default Recognition\r\n"]},"metadata":{},"sourceType":"module"}