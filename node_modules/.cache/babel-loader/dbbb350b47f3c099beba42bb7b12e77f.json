{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n/**\n * Config settings for Conversation Translator\n */\nexport const ConversationTranslatorConfig = {\n  apiVersion: \"2.0\",\n  auth: {\n    placeholderRegion: \"westus\",\n    placeholderSubscriptionKey: \"abcdefghijklmnopqrstuvwxyz012345\"\n  },\n  clientAppId: \"FC539C22-1767-4F1F-84BC-B4D811114F15\",\n  defaultLanguageCode: \"en-US\",\n  defaultRequestOptions: {\n    headers: {\n      Accept: \"application/json\"\n    },\n    ignoreCache: false,\n    timeout: 5000\n  },\n  host: \"dev.microsofttranslator.com\",\n  params: {\n    apiVersion: \"api-version\",\n    authorization: \"Authorization\",\n    clientAppId: \"X-ClientAppId\",\n    correlationId: \"X-CorrelationId\",\n    languageCode: \"language\",\n    nickname: \"nickname\",\n    profanity: \"profanity\",\n    requestId: \"X-RequestId\",\n    roomId: \"roomid\",\n    sessionToken: \"token\",\n    subscriptionKey: \"Ocp-Apim-Subscription-Key\",\n    subscriptionRegion: \"Ocp-Apim-Subscription-Region\",\n    token: \"X-CapitoToken\"\n  },\n  restPath: \"/capito/room\",\n  speechHost: \"{region}.s2s.speech.microsoft.com\",\n  speechPath: \"/speech/translation/cognitiveservices/v1\",\n  strings: {\n    authInvalidSubscriptionKey: \"You must specify either an authentication token to use, or a Cognitive Speech subscription key.\",\n    authInvalidSubscriptionRegion: \"You must specify the Cognitive Speech region to use.\",\n    invalidArgs: \"Required input not found: {arg}.\",\n    invalidCreateJoinConversationResponse: \"Creating/Joining conversation failed with HTTP {status}.\",\n    invalidParticipantRequest: \"The requested participant was not found.\",\n    permissionDeniedConnect: \"Required credentials not found.\",\n    permissionDeniedConversation: \"Invalid operation: only the host can {command} the conversation.\",\n    permissionDeniedParticipant: \"Invalid operation: only the host can {command} a participant.\",\n    permissionDeniedSend: \"Invalid operation: the conversation is not in a connected state.\",\n    permissionDeniedStart: \"Invalid operation: there is already an active conversation.\"\n  },\n  textMessageMaxLength: 1000,\n  webSocketPath: \"/capito/translate\"\n};\n/**\n * Helpers for sending / receiving HTTPS requests / responses.\n * @param params\n */\n\nfunction queryParams(params = {}) {\n  return Object.keys(params).map(k => encodeURIComponent(k) + \"=\" + encodeURIComponent(params[k])).join(\"&\");\n}\n\nfunction withQuery(url, params = {}) {\n  const queryString = queryParams(params);\n  return queryString ? url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + queryString : url;\n}\n\nfunction parseXHRResult(xhr) {\n  return {\n    data: xhr.responseText,\n    headers: xhr.getAllResponseHeaders(),\n    json: () => JSON.parse(xhr.responseText),\n    ok: xhr.status >= 200 && xhr.status < 300,\n    status: xhr.status,\n    statusText: xhr.statusText\n  };\n}\n\nfunction errorResponse(xhr, message = null) {\n  return {\n    data: message || xhr.statusText,\n    headers: xhr.getAllResponseHeaders(),\n    json: () => JSON.parse(message || \"\\\"\" + xhr.statusText + \"\\\"\"),\n    ok: false,\n    status: xhr.status,\n    statusText: xhr.statusText\n  };\n}\n\nexport function extractHeaderValue(headerKey, headers) {\n  let headerValue = \"\";\n\n  try {\n    const arr = headers.trim().split(/[\\r\\n]+/);\n    const headerMap = {};\n    arr.forEach(line => {\n      const parts = line.split(\": \");\n      const header = parts.shift().toLowerCase();\n      const value = parts.join(\": \");\n      headerMap[header] = value;\n    });\n    headerValue = headerMap[headerKey.toLowerCase()];\n  } catch (e) {// ignore the error\n  }\n\n  return headerValue;\n}\nexport function request(method, url, queryParams = {}, body = null, options = ConversationTranslatorConfig.defaultRequestOptions, callback) {\n  const ignoreCache = options.ignoreCache || ConversationTranslatorConfig.defaultRequestOptions.ignoreCache;\n  const headers = options.headers || ConversationTranslatorConfig.defaultRequestOptions.headers;\n  const timeout = options.timeout || ConversationTranslatorConfig.defaultRequestOptions.timeout;\n  const xhr = new XMLHttpRequest();\n  xhr.open(method, withQuery(url, queryParams), true);\n\n  if (headers) {\n    Object.keys(headers).forEach(key => xhr.setRequestHeader(key, headers[key]));\n  }\n\n  if (ignoreCache) {\n    xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n  }\n\n  xhr.timeout = timeout;\n\n  xhr.onload = evt => {\n    callback(parseXHRResult(xhr));\n  };\n\n  xhr.onerror = evt => {\n    callback(errorResponse(xhr, \"Failed to make request.\"));\n  };\n\n  xhr.ontimeout = evt => {\n    callback(errorResponse(xhr, \"Request took longer than expected.\"));\n  };\n\n  if (method === \"post\" && body) {\n    xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n    xhr.send(JSON.stringify(body));\n  } else {\n    xhr.send();\n  }\n}\nexport function PromiseToEmptyCallback(promise, cb, err) {\n  if (!!promise) {\n    promise.continueWith(antecedent => {\n      try {\n        if (antecedent.isError) {\n          if (!!err) {\n            err(antecedent.error);\n          }\n        } else {\n          if (!!cb) {\n            cb();\n          }\n        }\n      } catch (e) {\n        if (!!err) {\n          err(`'Unhandled error on promise callback: ${e}. InnerError: ${antecedent.error}'`);\n        }\n      }\n    });\n  } else {\n    if (!!err) {\n      err(\"Null promise\");\n    }\n  }\n}","map":{"version":3,"sources":["src/common.speech/Transcription/ConversationUtils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { Promise, PromiseResult } from \"../../common/Promise\";\r\nimport { Callback } from \"../../sdk/Transcription/IConversation\";\r\nimport { IRequestOptions, IResponse } from \"./ConversationTranslatorInterfaces\";\r\n\r\n/**\r\n * Config settings for Conversation Translator\r\n */\r\nexport const ConversationTranslatorConfig = {\r\n    apiVersion: \"2.0\",\r\n    auth: {\r\n        placeholderRegion: \"westus\",\r\n        placeholderSubscriptionKey: \"abcdefghijklmnopqrstuvwxyz012345\",\r\n    },\r\n    clientAppId: \"FC539C22-1767-4F1F-84BC-B4D811114F15\",\r\n    defaultLanguageCode: \"en-US\",\r\n    defaultRequestOptions: {\r\n        headers: {\r\n            Accept: \"application/json\",\r\n        },\r\n        ignoreCache: false,\r\n        timeout: 5000,\r\n    },\r\n    host: \"dev.microsofttranslator.com\",\r\n    params: {\r\n        apiVersion: \"api-version\",\r\n        authorization: \"Authorization\",\r\n        clientAppId: \"X-ClientAppId\",\r\n        correlationId: \"X-CorrelationId\",\r\n        languageCode: \"language\",\r\n        nickname: \"nickname\",\r\n        profanity: \"profanity\",\r\n        requestId: \"X-RequestId\",\r\n        roomId: \"roomid\",\r\n        sessionToken: \"token\",\r\n        subscriptionKey: \"Ocp-Apim-Subscription-Key\",\r\n        subscriptionRegion: \"Ocp-Apim-Subscription-Region\",\r\n        token: \"X-CapitoToken\",\r\n    },\r\n    restPath: \"/capito/room\",\r\n    speechHost: \"{region}.s2s.speech.microsoft.com\",\r\n    speechPath: \"/speech/translation/cognitiveservices/v1\",\r\n    strings: {\r\n        authInvalidSubscriptionKey: \"You must specify either an authentication token to use, or a Cognitive Speech subscription key.\",\r\n        authInvalidSubscriptionRegion: \"You must specify the Cognitive Speech region to use.\",\r\n        invalidArgs: \"Required input not found: {arg}.\",\r\n        invalidCreateJoinConversationResponse: \"Creating/Joining conversation failed with HTTP {status}.\",\r\n        invalidParticipantRequest: \"The requested participant was not found.\",\r\n        permissionDeniedConnect: \"Required credentials not found.\",\r\n        permissionDeniedConversation: \"Invalid operation: only the host can {command} the conversation.\",\r\n        permissionDeniedParticipant: \"Invalid operation: only the host can {command} a participant.\",\r\n        permissionDeniedSend: \"Invalid operation: the conversation is not in a connected state.\",\r\n        permissionDeniedStart: \"Invalid operation: there is already an active conversation.\",\r\n    },\r\n    textMessageMaxLength: 1000,\r\n    webSocketPath: \"/capito/translate\"\r\n};\r\n\r\n/**\r\n * Helpers for sending / receiving HTTPS requests / responses.\r\n * @param params\r\n */\r\nfunction queryParams(params: any = {}): any {\r\n    return Object.keys(params)\r\n        .map((k: any) => encodeURIComponent(k) + \"=\" + encodeURIComponent(params[k]))\r\n        .join(\"&\");\r\n}\r\n\r\nfunction withQuery(url: string, params: any = {}): any {\r\n    const queryString = queryParams(params);\r\n    return queryString ? url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + queryString : url;\r\n}\r\n\r\nfunction parseXHRResult(xhr: XMLHttpRequest): IResponse {\r\n    return {\r\n        data: xhr.responseText,\r\n        headers: xhr.getAllResponseHeaders(),\r\n        json: <T>() => JSON.parse(xhr.responseText) as T,\r\n        ok: xhr.status >= 200 && xhr.status < 300,\r\n        status: xhr.status,\r\n        statusText: xhr.statusText,\r\n    };\r\n}\r\n\r\nfunction errorResponse(xhr: XMLHttpRequest, message: string | null = null): IResponse {\r\n    return {\r\n        data: message || xhr.statusText,\r\n        headers: xhr.getAllResponseHeaders(),\r\n        json: <T>() => JSON.parse(message || (\"\\\"\" + xhr.statusText + \"\\\"\")) as T,\r\n      ok: false,\r\n      status: xhr.status,\r\n      statusText: xhr.statusText,\r\n    };\r\n}\r\n\r\nexport function extractHeaderValue(headerKey: string, headers: string): string {\r\n\r\n    let headerValue: string = \"\";\r\n\r\n    try {\r\n      const arr = headers.trim().split(/[\\r\\n]+/);\r\n      const headerMap: any = {};\r\n      arr.forEach((line: any) => {\r\n        const parts = line.split(\": \");\r\n        const header = parts.shift().toLowerCase();\r\n        const value = parts.join(\": \");\r\n        headerMap[header] = value;\r\n      });\r\n\r\n      headerValue = headerMap[headerKey.toLowerCase()];\r\n    } catch (e) {\r\n      // ignore the error\r\n    }\r\n\r\n    return headerValue;\r\n}\r\n\r\nexport function request(method: \"get\" | \"post\" | \"delete\",\r\n                        url: string,\r\n                        queryParams: any = {},\r\n                        body: any = null,\r\n                        options: IRequestOptions = ConversationTranslatorConfig.defaultRequestOptions,\r\n                        callback: any): any {\r\n\r\n    const ignoreCache = options.ignoreCache || ConversationTranslatorConfig.defaultRequestOptions.ignoreCache;\r\n    const headers = options.headers || ConversationTranslatorConfig.defaultRequestOptions.headers;\r\n    const timeout = options.timeout || ConversationTranslatorConfig.defaultRequestOptions.timeout;\r\n\r\n    const xhr = new XMLHttpRequest();\r\n    xhr.open(method, withQuery(url, queryParams), true);\r\n\r\n    if (headers) {\r\n        Object.keys(headers).forEach((key: any) => xhr.setRequestHeader(key, headers[key]));\r\n    }\r\n\r\n    if (ignoreCache) {\r\n        xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\r\n    }\r\n\r\n    xhr.timeout = timeout;\r\n\r\n    xhr.onload = (evt: any) => {\r\n        callback(parseXHRResult(xhr));\r\n    };\r\n\r\n    xhr.onerror = (evt: any) => {\r\n        callback(errorResponse(xhr, \"Failed to make request.\"));\r\n    };\r\n\r\n    xhr.ontimeout = (evt: any) => {\r\n        callback(errorResponse(xhr, \"Request took longer than expected.\"));\r\n    };\r\n\r\n    if (method === \"post\" && body) {\r\n        xhr.setRequestHeader(\"Content-Type\", \"application/json\");\r\n        xhr.send(JSON.stringify(body));\r\n    } else {\r\n        xhr.send();\r\n    }\r\n}\r\n\r\nexport function PromiseToEmptyCallback<T>(promise: Promise<T>, cb?: Callback, err?: Callback): void {\r\n    if (!!promise) {\r\n        promise.continueWith((antecedent: PromiseResult<T>): void => {\r\n            try {\r\n                if (antecedent.isError) {\r\n                    if (!!err) {\r\n                        err(antecedent.error);\r\n                    }\r\n                } else {\r\n                    if (!!cb) {\r\n                        cb();\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                if (!!err) {\r\n                    err(`'Unhandled error on promise callback: ${e}. InnerError: ${antecedent.error}'`);\r\n                }\r\n            }\r\n        });\r\n    } else {\r\n        if (!!err) {\r\n            err(\"Null promise\");\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}