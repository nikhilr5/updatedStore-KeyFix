{"ast":null,"code":"//\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\nimport { ConnectionMessageImpl } from \"./ConnectionMessage\";\nimport { ConnectionEventArgs, ConnectionMessageEventArgs, ServiceEventArgs } from \"./Exports\";\n/**\n * Connection is a proxy class for managing connection to the speech service of the specified Recognizer.\n * By default, a Recognizer autonomously manages connection to service when needed.\n * The Connection class provides additional methods for users to explicitly open or close a connection and\n * to subscribe to connection status changes.\n * The use of Connection is optional, and mainly for scenarios where fine tuning of application\n * behavior based on connection status is needed. Users can optionally call Open() to manually set up a connection\n * in advance before starting recognition on the Recognizer associated with this Connection.\n * If the Recognizer needs to connect or disconnect to service, it will\n * setup or shutdown the connection independently. In this case the Connection will be notified by change of connection\n * status via Connected/Disconnected events.\n * Added in version 1.2.0.\n */\n\nexport class Connection {\n  /**\n   * Gets the Connection instance from the specified recognizer.\n   * @param recognizer The recognizer associated with the connection.\n   * @return The Connection instance of the recognizer.\n   */\n  static fromRecognizer(recognizer) {\n    const recoBase = recognizer.internalData;\n    const ret = new Connection();\n    ret.privServiceRecognizer = recoBase;\n    ret.privEventListener = ret.privServiceRecognizer.connectionEvents.attach(connectionEvent => {\n      if (connectionEvent.name === \"ConnectionEstablishedEvent\") {\n        if (!!ret.connected) {\n          ret.connected(new ConnectionEventArgs(connectionEvent.connectionId));\n        }\n      } else if (connectionEvent.name === \"ConnectionClosedEvent\") {\n        if (!!ret.disconnected) {\n          ret.disconnected(new ConnectionEventArgs(connectionEvent.connectionId));\n        }\n      } else if (connectionEvent.name === \"ConnectionMessageSentEvent\") {\n        if (!!ret.messageSent) {\n          ret.messageSent(new ConnectionMessageEventArgs(new ConnectionMessageImpl(connectionEvent.message)));\n        }\n      } else if (connectionEvent.name === \"ConnectionMessageReceivedEvent\") {\n        if (!!ret.messageReceived) {\n          ret.messageReceived(new ConnectionMessageEventArgs(new ConnectionMessageImpl(connectionEvent.message)));\n        }\n      }\n    });\n    ret.privServiceEventListener = ret.privServiceRecognizer.serviceEvents.attach(e => {\n      if (!!ret.receivedServiceMessage) {\n        ret.receivedServiceMessage(new ServiceEventArgs(e.jsonString, e.name));\n      }\n    });\n    return ret;\n  }\n  /**\n   * Starts to set up connection to the service.\n   * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the\n   * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect\n   *\n   * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to\n   * be notfied when the connection is established.\n   */\n\n\n  openConnection() {\n    this.privServiceRecognizer.connect();\n  }\n  /**\n   * Closes the connection the service.\n   * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.\n   *\n   * If closeConnection() is called during recognition, recognition will fail and cancel with an error.\n   */\n\n\n  closeConnection() {\n    this.privServiceRecognizer.disconnect();\n  }\n  /**\n   * Dispose of associated resources.\n   */\n\n\n  close() {\n    /* tslint:disable:no-empty */\n  }\n\n}","map":{"version":3,"sources":["src/sdk/Connection.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AAYA,SACI,qBADJ,QAEO,qBAFP;AAGA,SACI,mBADJ,EAEI,0BAFJ,EAII,gBAJJ,QAKO,WALP;AAOA;;;;;;;;;;;;;;AAaA,OAAM,MAAO,UAAP,CAAiB;AAKnB;;;;;AAKO,SAAO,cAAP,CAAsB,UAAtB,EAA4C;AAC/C,UAAM,QAAQ,GAA0B,UAAU,CAAC,YAAnD;AAEA,UAAM,GAAG,GAAe,IAAI,UAAJ,EAAxB;AAEA,IAAA,GAAG,CAAC,qBAAJ,GAA4B,QAA5B;AACA,IAAA,GAAG,CAAC,iBAAJ,GAAwB,GAAG,CAAC,qBAAJ,CAA0B,gBAA1B,CAA2C,MAA3C,CAAmD,eAAD,IAA2C;AACjH,UAAI,eAAe,CAAC,IAAhB,KAAyB,4BAA7B,EAA2D;AACvD,YAAI,CAAC,CAAC,GAAG,CAAC,SAAV,EAAqB;AACjB,UAAA,GAAG,CAAC,SAAJ,CAAc,IAAI,mBAAJ,CAAwB,eAAe,CAAC,YAAxC,CAAd;AACH;AACJ,OAJD,MAIO,IAAI,eAAe,CAAC,IAAhB,KAAyB,uBAA7B,EAAsD;AACzD,YAAI,CAAC,CAAC,GAAG,CAAC,YAAV,EAAwB;AACpB,UAAA,GAAG,CAAC,YAAJ,CAAiB,IAAI,mBAAJ,CAAwB,eAAe,CAAC,YAAxC,CAAjB;AACH;AACJ,OAJM,MAIA,IAAI,eAAe,CAAC,IAAhB,KAAyB,4BAA7B,EAA2D;AAC9D,YAAI,CAAC,CAAC,GAAG,CAAC,WAAV,EAAuB;AACnB,UAAA,GAAG,CAAC,WAAJ,CAAgB,IAAI,0BAAJ,CAA+B,IAAI,qBAAJ,CAA2B,eAA8C,CAAC,OAA1E,CAA/B,CAAhB;AACH;AACJ,OAJM,MAIA,IAAI,eAAe,CAAC,IAAhB,KAAyB,gCAA7B,EAA+D;AAClE,YAAI,CAAC,CAAC,GAAG,CAAC,eAAV,EAA2B;AACvB,UAAA,GAAG,CAAC,eAAJ,CAAoB,IAAI,0BAAJ,CAA+B,IAAI,qBAAJ,CAA2B,eAAkD,CAAC,OAA9E,CAA/B,CAApB;AACH;AACJ;AACJ,KAlBuB,CAAxB;AAoBA,IAAA,GAAG,CAAC,wBAAJ,GAA+B,GAAG,CAAC,qBAAJ,CAA0B,aAA1B,CAAwC,MAAxC,CAAgD,CAAD,IAA0B;AACpG,UAAI,CAAC,CAAC,GAAG,CAAC,sBAAV,EAAkC;AAC9B,QAAA,GAAG,CAAC,sBAAJ,CAA2B,IAAI,gBAAJ,CAAqB,CAAC,CAAC,UAAvB,EAAmC,CAAC,CAAC,IAArC,CAA3B;AACH;AACJ,KAJ8B,CAA/B;AAMA,WAAO,GAAP;AACH;AAED;;;;;;;;;;AAQO,EAAA,cAAc,GAAA;AACjB,SAAK,qBAAL,CAA2B,OAA3B;AACH;AAED;;;;;;;;AAMO,EAAA,eAAe,GAAA;AAClB,SAAK,qBAAL,CAA2B,UAA3B;AACH;AA6BD;;;;;AAGO,EAAA,KAAK,GAAA;AACR;AACH;;AAnGkB","sourcesContent":["//\r\n// Copyright (c) Microsoft. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\r\n//\r\n\r\nimport {\r\n    ServiceRecognizerBase,\r\n} from \"../common.speech/Exports\";\r\nimport {\r\n    ConnectionEvent,\r\n    ConnectionMessageReceivedEvent,\r\n    ConnectionMessageSentEvent,\r\n    IDetachable,\r\n    ServiceEvent,\r\n} from \"../common/Exports\";\r\nimport {\r\n    ConnectionMessageImpl\r\n} from \"./ConnectionMessage\";\r\nimport {\r\n    ConnectionEventArgs,\r\n    ConnectionMessageEventArgs,\r\n    Recognizer,\r\n    ServiceEventArgs,\r\n} from \"./Exports\";\r\n\r\n/**\r\n * Connection is a proxy class for managing connection to the speech service of the specified Recognizer.\r\n * By default, a Recognizer autonomously manages connection to service when needed.\r\n * The Connection class provides additional methods for users to explicitly open or close a connection and\r\n * to subscribe to connection status changes.\r\n * The use of Connection is optional, and mainly for scenarios where fine tuning of application\r\n * behavior based on connection status is needed. Users can optionally call Open() to manually set up a connection\r\n * in advance before starting recognition on the Recognizer associated with this Connection.\r\n * If the Recognizer needs to connect or disconnect to service, it will\r\n * setup or shutdown the connection independently. In this case the Connection will be notified by change of connection\r\n * status via Connected/Disconnected events.\r\n * Added in version 1.2.0.\r\n */\r\nexport class Connection {\r\n    private privServiceRecognizer: ServiceRecognizerBase;\r\n    private privEventListener: IDetachable;\r\n    private privServiceEventListener: IDetachable;\r\n\r\n    /**\r\n     * Gets the Connection instance from the specified recognizer.\r\n     * @param recognizer The recognizer associated with the connection.\r\n     * @return The Connection instance of the recognizer.\r\n     */\r\n    public static fromRecognizer(recognizer: Recognizer): Connection {\r\n        const recoBase: ServiceRecognizerBase = recognizer.internalData as ServiceRecognizerBase;\r\n\r\n        const ret: Connection = new Connection();\r\n\r\n        ret.privServiceRecognizer = recoBase;\r\n        ret.privEventListener = ret.privServiceRecognizer.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\r\n            if (connectionEvent.name === \"ConnectionEstablishedEvent\") {\r\n                if (!!ret.connected) {\r\n                    ret.connected(new ConnectionEventArgs(connectionEvent.connectionId));\r\n                }\r\n            } else if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                if (!!ret.disconnected) {\r\n                    ret.disconnected(new ConnectionEventArgs(connectionEvent.connectionId));\r\n                }\r\n            } else if (connectionEvent.name === \"ConnectionMessageSentEvent\") {\r\n                if (!!ret.messageSent) {\r\n                    ret.messageSent(new ConnectionMessageEventArgs(new ConnectionMessageImpl((connectionEvent as ConnectionMessageSentEvent).message)));\r\n                }\r\n            } else if (connectionEvent.name === \"ConnectionMessageReceivedEvent\") {\r\n                if (!!ret.messageReceived) {\r\n                    ret.messageReceived(new ConnectionMessageEventArgs(new ConnectionMessageImpl((connectionEvent as ConnectionMessageReceivedEvent).message)));\r\n                }\r\n            }\r\n        });\r\n\r\n        ret.privServiceEventListener = ret.privServiceRecognizer.serviceEvents.attach((e: ServiceEvent): void => {\r\n            if (!!ret.receivedServiceMessage) {\r\n                ret.receivedServiceMessage(new ServiceEventArgs(e.jsonString, e.name));\r\n            }\r\n        });\r\n\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Starts to set up connection to the service.\r\n     * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the\r\n     * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect\r\n     *\r\n     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to\r\n     * be notfied when the connection is established.\r\n     */\r\n    public openConnection(): void {\r\n        this.privServiceRecognizer.connect();\r\n    }\r\n\r\n    /**\r\n     * Closes the connection the service.\r\n     * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.\r\n     *\r\n     * If closeConnection() is called during recognition, recognition will fail and cancel with an error.\r\n     */\r\n    public closeConnection(): void {\r\n        this.privServiceRecognizer.disconnect();\r\n    }\r\n\r\n    /**\r\n     * Any message from service that is not being processed by any other top level recognizers.\r\n     *\r\n     * Will be removed in 2.0.\r\n     */\r\n    public receivedServiceMessage: (args: ServiceEventArgs) => void;\r\n\r\n    /**\r\n     * Any message received from the Speech Service.\r\n     */\r\n    public messageReceived: (args: ConnectionMessageEventArgs) => void;\r\n\r\n    /**\r\n     * Any message sent to the Speech Service.\r\n     */\r\n    public messageSent: (args: ConnectionMessageEventArgs) => void;\r\n\r\n    /**\r\n     * The Connected event to indicate that the recognizer is connected to service.\r\n     */\r\n    public connected: (args: ConnectionEventArgs) => void;\r\n\r\n    /**\r\n     * The Diconnected event to indicate that the recognizer is disconnected from service.\r\n     */\r\n    public disconnected: (args: ConnectionEventArgs) => void;\r\n\r\n    /**\r\n     * Dispose of associated resources.\r\n     */\r\n    public close(): void {\r\n        /* tslint:disable:no-empty */\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}