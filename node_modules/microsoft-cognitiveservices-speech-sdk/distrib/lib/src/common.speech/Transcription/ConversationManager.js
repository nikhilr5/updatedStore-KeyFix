"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
var Contracts_1 = require("../../sdk/Contracts");
var Exports_1 = require("../../sdk/Exports");
var ConversationUtils_1 = require("./ConversationUtils");
var ConversationManager = /** @class */ (function () {
    function ConversationManager() {
        //
    }
    /**
     * Make a POST request to the Conversation Manager service endpoint to create or join a conversation.
     * @param args
     * @param conversationCode
     * @param callback
     * @param errorCallback
     */
    ConversationManager.prototype.createOrJoin = function (args, conversationCode, cb, err) {
        try {
            Contracts_1.Contracts.throwIfNullOrUndefined(args, "args");
            var languageCode = args.getProperty(Exports_1.PropertyId.SpeechServiceConnection_RecoLanguage, ConversationUtils_1.ConversationTranslatorConfig.defaultLanguageCode);
            var nickname = args.getProperty(Exports_1.PropertyId.ConversationTranslator_Name);
            var endpointHost = args.getProperty(Exports_1.PropertyId.ConversationTranslator_Host, ConversationUtils_1.ConversationTranslatorConfig.host);
            var correlationId = args.getProperty(Exports_1.PropertyId.ConversationTranslator_CorrelationId);
            var subscriptionKey = args.getProperty(Exports_1.PropertyId.SpeechServiceConnection_Key);
            var subscriptionRegion = args.getProperty(Exports_1.PropertyId.SpeechServiceConnection_Region);
            var authToken = args.getProperty(Exports_1.PropertyId.SpeechServiceAuthorization_Token);
            Contracts_1.Contracts.throwIfNullOrWhitespace(languageCode, "languageCode");
            Contracts_1.Contracts.throwIfNullOrWhitespace(nickname, "nickname");
            Contracts_1.Contracts.throwIfNullOrWhitespace(endpointHost, "endpointHost");
            var queryParams = {};
            queryParams[ConversationUtils_1.ConversationTranslatorConfig.params.apiVersion] = ConversationUtils_1.ConversationTranslatorConfig.apiVersion;
            queryParams[ConversationUtils_1.ConversationTranslatorConfig.params.languageCode] = languageCode;
            queryParams[ConversationUtils_1.ConversationTranslatorConfig.params.nickname] = nickname;
            var headers = {};
            if (correlationId) {
                headers[ConversationUtils_1.ConversationTranslatorConfig.params.correlationId] = correlationId;
            }
            headers[ConversationUtils_1.ConversationTranslatorConfig.params.clientAppId] = ConversationUtils_1.ConversationTranslatorConfig.clientAppId;
            if (conversationCode !== undefined) {
                queryParams[ConversationUtils_1.ConversationTranslatorConfig.params.roomId] = conversationCode;
            }
            else {
                Contracts_1.Contracts.throwIfNullOrUndefined(subscriptionRegion, ConversationUtils_1.ConversationTranslatorConfig.strings.authInvalidSubscriptionRegion);
                headers[ConversationUtils_1.ConversationTranslatorConfig.params.subscriptionRegion] = subscriptionRegion;
                if (subscriptionKey) {
                    headers[ConversationUtils_1.ConversationTranslatorConfig.params.subscriptionKey] = subscriptionKey;
                }
                else if (authToken) {
                    headers[ConversationUtils_1.ConversationTranslatorConfig.params.authorization] = "Bearer " + authToken;
                }
                else {
                    Contracts_1.Contracts.throwIfNullOrUndefined(subscriptionKey, ConversationUtils_1.ConversationTranslatorConfig.strings.authInvalidSubscriptionKey);
                }
            }
            var config = {};
            config.headers = headers;
            var endpoint = "https://" + endpointHost + ConversationUtils_1.ConversationTranslatorConfig.restPath;
            // TODO: support a proxy and certificate validation
            ConversationUtils_1.request("post", endpoint, queryParams, null, config, function (response) {
                var requestId = ConversationUtils_1.extractHeaderValue(ConversationUtils_1.ConversationTranslatorConfig.params.requestId, response.headers);
                if (!response.ok) {
                    if (!!err) {
                        // get the error
                        var errorMessage = ConversationUtils_1.ConversationTranslatorConfig.strings.invalidCreateJoinConversationResponse.replace("{status}", response.status.toString());
                        var errMessageRaw = void 0;
                        try {
                            errMessageRaw = JSON.parse(response.data);
                            errorMessage += " [" + errMessageRaw.error.code + ": " + errMessageRaw.error.message + "]";
                        }
                        catch (e) {
                            errorMessage += " [" + response.data + "]";
                        }
                        if (requestId) {
                            errorMessage += " " + requestId;
                        }
                        err(errorMessage);
                    }
                    return;
                }
                var conversation = JSON.parse(response.data);
                if (conversation) {
                    conversation.requestId = requestId;
                }
                if (!!cb) {
                    try {
                        cb(conversation);
                    }
                    catch (e) {
                        if (!!err) {
                            err(e);
                        }
                    }
                    cb = undefined;
                }
            });
        }
        catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    var typedError = error;
                    err(typedError.name + ": " + typedError.message);
                }
                else {
                    err(error);
                }
            }
        }
    };
    /**
     * Make a DELETE request to the Conversation Manager service endpoint to leave the conversation.
     * @param args
     * @param sessionToken
     * @param callback
     */
    ConversationManager.prototype.leave = function (args, sessionToken, cb, err) {
        try {
            Contracts_1.Contracts.throwIfNullOrUndefined(args, ConversationUtils_1.ConversationTranslatorConfig.strings.invalidArgs.replace("{arg}", "config"));
            Contracts_1.Contracts.throwIfNullOrWhitespace(sessionToken, ConversationUtils_1.ConversationTranslatorConfig.strings.invalidArgs.replace("{arg}", "token"));
            var endpointHost = args.getProperty(Exports_1.PropertyId.ConversationTranslator_Host, ConversationUtils_1.ConversationTranslatorConfig.host);
            var correlationId = args.getProperty(Exports_1.PropertyId.ConversationTranslator_CorrelationId);
            var queryParams = {};
            queryParams[ConversationUtils_1.ConversationTranslatorConfig.params.apiVersion] = ConversationUtils_1.ConversationTranslatorConfig.apiVersion;
            queryParams[ConversationUtils_1.ConversationTranslatorConfig.params.sessionToken] = sessionToken;
            var headers = {};
            if (correlationId) {
                headers[ConversationUtils_1.ConversationTranslatorConfig.params.correlationId] = correlationId;
            }
            var config = {};
            config.headers = headers;
            var endpoint = "https://" + endpointHost + ConversationUtils_1.ConversationTranslatorConfig.restPath;
            // TODO: support a proxy and certificate validation
            ConversationUtils_1.request("delete", endpoint, queryParams, null, config, function (response) {
                if (!response.ok) {
                    // ignore errors on delete
                }
                if (!!cb) {
                    try {
                        cb();
                    }
                    catch (e) {
                        if (!!err) {
                            err(e);
                        }
                    }
                    cb = undefined;
                }
            });
        }
        catch (error) {
            if (!!err) {
                if (error instanceof Error) {
                    var typedError = error;
                    err(typedError.name + ": " + typedError.message);
                }
                else {
                    err(error);
                }
            }
        }
    };
    return ConversationManager;
}());
exports.ConversationManager = ConversationManager;

//# sourceMappingURL=ConversationManager.js.map
