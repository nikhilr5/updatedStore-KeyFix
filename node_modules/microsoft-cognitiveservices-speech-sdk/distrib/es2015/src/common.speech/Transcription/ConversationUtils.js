// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
/**
 * Config settings for Conversation Translator
 */
export const ConversationTranslatorConfig = {
    apiVersion: "2.0",
    auth: {
        placeholderRegion: "westus",
        placeholderSubscriptionKey: "abcdefghijklmnopqrstuvwxyz012345",
    },
    clientAppId: "FC539C22-1767-4F1F-84BC-B4D811114F15",
    defaultLanguageCode: "en-US",
    defaultRequestOptions: {
        headers: {
            Accept: "application/json",
        },
        ignoreCache: false,
        timeout: 5000,
    },
    host: "dev.microsofttranslator.com",
    params: {
        apiVersion: "api-version",
        authorization: "Authorization",
        clientAppId: "X-ClientAppId",
        correlationId: "X-CorrelationId",
        languageCode: "language",
        nickname: "nickname",
        profanity: "profanity",
        requestId: "X-RequestId",
        roomId: "roomid",
        sessionToken: "token",
        subscriptionKey: "Ocp-Apim-Subscription-Key",
        subscriptionRegion: "Ocp-Apim-Subscription-Region",
        token: "X-CapitoToken",
    },
    restPath: "/capito/room",
    speechHost: "{region}.s2s.speech.microsoft.com",
    speechPath: "/speech/translation/cognitiveservices/v1",
    strings: {
        authInvalidSubscriptionKey: "You must specify either an authentication token to use, or a Cognitive Speech subscription key.",
        authInvalidSubscriptionRegion: "You must specify the Cognitive Speech region to use.",
        invalidArgs: "Required input not found: {arg}.",
        invalidCreateJoinConversationResponse: "Creating/Joining conversation failed with HTTP {status}.",
        invalidParticipantRequest: "The requested participant was not found.",
        permissionDeniedConnect: "Required credentials not found.",
        permissionDeniedConversation: "Invalid operation: only the host can {command} the conversation.",
        permissionDeniedParticipant: "Invalid operation: only the host can {command} a participant.",
        permissionDeniedSend: "Invalid operation: the conversation is not in a connected state.",
        permissionDeniedStart: "Invalid operation: there is already an active conversation.",
    },
    textMessageMaxLength: 1000,
    webSocketPath: "/capito/translate"
};
/**
 * Helpers for sending / receiving HTTPS requests / responses.
 * @param params
 */
function queryParams(params = {}) {
    return Object.keys(params)
        .map((k) => encodeURIComponent(k) + "=" + encodeURIComponent(params[k]))
        .join("&");
}
function withQuery(url, params = {}) {
    const queryString = queryParams(params);
    return queryString ? url + (url.indexOf("?") === -1 ? "?" : "&") + queryString : url;
}
function parseXHRResult(xhr) {
    return {
        data: xhr.responseText,
        headers: xhr.getAllResponseHeaders(),
        json: () => JSON.parse(xhr.responseText),
        ok: xhr.status >= 200 && xhr.status < 300,
        status: xhr.status,
        statusText: xhr.statusText,
    };
}
function errorResponse(xhr, message = null) {
    return {
        data: message || xhr.statusText,
        headers: xhr.getAllResponseHeaders(),
        json: () => JSON.parse(message || ("\"" + xhr.statusText + "\"")),
        ok: false,
        status: xhr.status,
        statusText: xhr.statusText,
    };
}
export function extractHeaderValue(headerKey, headers) {
    let headerValue = "";
    try {
        const arr = headers.trim().split(/[\r\n]+/);
        const headerMap = {};
        arr.forEach((line) => {
            const parts = line.split(": ");
            const header = parts.shift().toLowerCase();
            const value = parts.join(": ");
            headerMap[header] = value;
        });
        headerValue = headerMap[headerKey.toLowerCase()];
    }
    catch (e) {
        // ignore the error
    }
    return headerValue;
}
export function request(method, url, queryParams = {}, body = null, options = ConversationTranslatorConfig.defaultRequestOptions, callback) {
    const ignoreCache = options.ignoreCache || ConversationTranslatorConfig.defaultRequestOptions.ignoreCache;
    const headers = options.headers || ConversationTranslatorConfig.defaultRequestOptions.headers;
    const timeout = options.timeout || ConversationTranslatorConfig.defaultRequestOptions.timeout;
    const xhr = new XMLHttpRequest();
    xhr.open(method, withQuery(url, queryParams), true);
    if (headers) {
        Object.keys(headers).forEach((key) => xhr.setRequestHeader(key, headers[key]));
    }
    if (ignoreCache) {
        xhr.setRequestHeader("Cache-Control", "no-cache");
    }
    xhr.timeout = timeout;
    xhr.onload = (evt) => {
        callback(parseXHRResult(xhr));
    };
    xhr.onerror = (evt) => {
        callback(errorResponse(xhr, "Failed to make request."));
    };
    xhr.ontimeout = (evt) => {
        callback(errorResponse(xhr, "Request took longer than expected."));
    };
    if (method === "post" && body) {
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.send(JSON.stringify(body));
    }
    else {
        xhr.send();
    }
}
export function PromiseToEmptyCallback(promise, cb, err) {
    if (!!promise) {
        promise.continueWith((antecedent) => {
            try {
                if (antecedent.isError) {
                    if (!!err) {
                        err(antecedent.error);
                    }
                }
                else {
                    if (!!cb) {
                        cb();
                    }
                }
            }
            catch (e) {
                if (!!err) {
                    err(`'Unhandled error on promise callback: ${e}. InnerError: ${antecedent.error}'`);
                }
            }
        });
    }
    else {
        if (!!err) {
            err("Null promise");
        }
    }
}

//# sourceMappingURL=ConversationUtils.js.map
